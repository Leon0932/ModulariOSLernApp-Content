{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"swift/","text":"Learn Swift Table of contents Beginner Module 1: Introduction to Swift Swift Basics Comments in Swift Module 2: Basic concepts in Swift Introduction Type Annotations Integers and Floating-Points Strings and Characters Booleans Operators Enumerations Module 3: Control Flows Conditionals Loops Control Transfers Module 4: Functions Introduction Specify Argument and Parameters Function Types Intermediate Module 5: Optionals Theory Binding Chaining Nil-Coalescing Operator Unconditional Unwrapping Module 6: Collection Types Start Arrays Sets Dictionaries Module 7: Object oriented programming Classes and Structure Declaration Inheritance Protocols Extensions Module 8: Error Handling Start Representing / Throwing Errors Handling Errors Advanced Module 9: Functional Programming Closures Generics Module 10: Advanced Swift-Lectures Property Observers Type Casting Level Beginners Module 1: Introduction to Swift Swift Basics A variable can be created using the keyword var . Constants can be created using let . To print the value out, use the function print() . Unlike other languages like C or C++, you don't need to specify the data type. The compiler recognizes the data types automatically. In the next module, you will learn about different data types. var variable1 = 0 let constant = 1 print(variable1) print(constant) variable1 = 5 print(variable1) // Compiler-Error // constant = 10 Swift Documentation: The Basics Comments in Swift Use comments to include nonexecutable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled. Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes ( // ). Multiline comments start with a forward-slash followed by an asterisk ( /* ) and end with an asterisk followed by a forward-slash ( */ ): // This is a comment /* This is also a comment but is written over multiple lines. */ Swift Documentation: Comments Module 2: Basic concepts in Swift Introduction Constants and variables must be declared before they\u2019re used. You declare constants with the let keyword and variables with the var keyword. Here\u2019s an example of how constants and variables can be used to track the number of login attempts a user has made. The result will get with print printed out. Use String Interpolation ( \\( ) ) to print out the variable in a String . let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 print(\"The maximum number of login attempts is \\(maximumNumberOfLoginAttempts)\") print(\"The current number of login attempts is \\(currentLoginAttempt)\") Swift Documentation: Declaring Constants and Variables Type Annotations You can provide a type annotation when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use. This example provides a type annotation for a variable called welcomeMessage , to indicate that the variable can store String values: var welcomeMessage: String // The welcomeMessage variable can now be set to any string value without error: welcomeMessage = \"Hello\" print(welcomeMessage) Swift Documentation: Type Annotations Integers and Floating-Points Integers are whole numbers with no fractional component, such as 42 and -23. Integers are either signed (positive, zero, or negative) or unsigned (positive or zero). Floating-point numbers are numbers with a fractional component, such as 3.14159, 0.1, and -273.15. Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an Int. Swift provides two signed floating-point number types: Double represents a 64-bit floating-point number. Float represents a 32-bit floating-point number. Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, Double is preferred. let age = 12 // int let note = 1.7 // double print(age) print(note) Swift Documentation: Int Strings and Characters A string is a series of characters, such as \"hello, world\" or \"albatross\". Swift strings are represented by the String type. The contents of a String can be accessed in various ways, including as a collection of Character values. You can include predefined String values within your code as string literals. A string literal is a sequence of characters surrounded by double quotation marks (\"\"). Use a string literal as an initial value for a constant or variable: let someString = \"Some string literal value\" print(someString) Swift Documentation: String Literals Booleans Swift has a basic Boolean type, called Bool . Boolean values are referred to as logical, because they can only ever be true or false . let orangesAreOrange = true let turnipsAreDelicious = false print(orangesAreOrange) print(turnipsAreDelicious) Swift Documentation: Booleans Operators Operators are unary, binary, or ternary: Unary operators operate on a single target (such as -a ). Unary prefix operators appear immediately before their target (such as !b ), and unary postfix operators appear immediately after their target (such as c! ). Binary operators operate on two targets (such as `2 + 3 ) and are infix because they appear in between their two targets. - Ternary operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator ( a ? b : c`). The values that operators affect are operands. In the expression 1 + 2 , the + symbol is an infix operator and its two operands are the values 1 and 2. // Unary Operators: -a // Binary Operators: 2 + 3 // Ternary Operators: a ? b : c Swift Documentation: Terminology Enumerations Enumerations (or enums ) in Swift are a powerful feature that allows you to define a common type for a group of related values and work with those values in a type-safe way. Swift enumerations are more flexible than their counterparts in many other languages. They can have associated values and methods. enum CompassPoint { case north case south case east case west } // or enum CompassPointVariant2 { case north, south, east, west } Swift Documentation: Enumeration Syntax Module 3: Control Flows Conditionals It\u2019s often useful to execute different pieces of code based on certain conditions. You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low. To do this, you make parts of your code conditional. Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute. if <statement> { // do something } switch <some value> { case <Nr. 1>: // do something case <Nr. 2>: // do something default: // do something } Swift Documentation: Control Flow Loops You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string. Here are some examples: // Iterate over the items in an array let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] for name in names { print(\"Hello, \\(name)!\") } // Iterate over a range of numbers from 1 to 5 for index in 1...5 { print(\"\\(index)! times 5 is \\(index * 5)!\") } // the half-open range operator (..<) includes the // lower bound but not the upper bound. // 1..<6 is equal to 1...5 // If you don\u2019t need each value from a sequence, // you can ignore the values by using an underscore // in place of a variable name. for _ in 1...5 { print(\"Loops are cool\") } Swift Documentation: For-In Loops Control Transfers Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue break fallthrough return throw The continue , break , and fallthrough statements are described below. The return statement is described in Module: Functions , and the throw statement is described in Module: Error Handling . for number in 1...10 { if number % 2 == 0 { continue } print(number) } for number in 1...10 { if number == 5 { break } print(number) } let number = 3 switch number { case 1: print(\"The number is 1\") case 2: print(\"The number is 2\") case 3: print(\"The number is 3\") fallthrough // Continue to the next case case 4: print(\"The number is 4\") fallthrough // Continue to the next case case 5: print(\"The number is 5\") default: print(\"The number is something else\") } Swift Documentation: Control Transfer Statements Module 4: Functions Introduction When defining a function , you can optionally define named, typed input values called parameters , and a type for the output value, known as the return type. Every function has a name describing its task. To use a function, you \"call\" it with its name and provide input values, or arguments, matching the function\u2019s parameters in the specified order. To demonstrate this, there are two functions: The function greet(person:) , takes a person\u2019s name as input and returns a greeting. It defines one input parameter\u2014a String called person\u2014and a return type of String for the greeting. The function helloWorld() takes no parameters and returns nothing; it only prints \"Hello World\". func greet(person: String) -> String { let greeting = \"Hello, \" + person + \"!\" return greeting } func helloWorld() { print(\"Hello World\") } print(greet(person: \"Anna\")) print(greet(person: \"Brian\")) helloWorld() Swift Documentation: Defining and Calling Functions Specify Argument and Parameters Each function parameter has both an argument label and a parameter name . The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label. You can specify an argument label before the parameter name, separated by a space. Here\u2019s a variation of the greet(person:) function that takes a person\u2019s name and hometown and returns a greeting: func greet(person: String, from hometown: String) -> String { return \"Hello \\(person)! Glad you could visit from \\(hometown).\" } print(greet(person: \"Bill\", from: \"Cupertino\")) Swift Documentation: Function Argument Labels and Parameter Names Function Types Every function has a specific function type , made up of the parameter types and the return type of the function. For example: func addTwoInts(_ a: Int, _ b: Int) -> Int { return a + b } func multiplyTwoInts(_ a: Int, _ b: Int) -> Int { return a * b } func printHelloWorld() { print(\"hello, world\") } The type of both of these functions is: (Int, Int) -> Int This can be read as: \u201cA function that has two parameters, both of type Int, and that returns a value of type Int.\u201d Here\u2019s another example, for a function with no parameters or return value: func printHelloWorld() { print(\"hello, world\") } The type of this function is () -> Void , or \u201ca function that has no parameters, and returns Void.\u201d Swift Documentation: Function Types Level Intermediate Module 5: Optionals Theory Optionals are a fundamental feature in Swift. They allow you to declare variables or constants that can either hold a value or be nil (no value). Swift\u2019s type system usually shows the wrapped type\u2019s name with a trailing question mark (?) instead of showing the full type name. For example, if a variable has the type Int? , that\u2019s just another way of writing Optional<Int> . var ageShort: Int? var ageLong: Optional<Int> Apple Documentation: Optional Binding To conditionally bind the wrapped value of an Optional instance to a new variable, use one of the optional binding control structures, including if let , guard let , and switch . Here are some examples: var age: Int? = nil if let unwrappedAge = age { print(unwrappedAge) } else { print(\"Age is nil\") } var name: String? = \"Max\" guard let unwrappedName = name else { print(\"Name is nil\") return } print(unwrappedName) Apple Documentation: Optional Binding Chaining To safely access the properties and methods of a wrapped instance, use the postfix optional chaining operator (postfix ? ). Here is an example (You will learn classes in the Module 7: Object Oriented Programming ): class Person { var residence: Residence? } class Residence { var numberOfRooms = 1 } let john = Person() if let roomCount = john.residence?.numberOfRooms { print(\"John's residence has \\(roomCount) room(s).\") } else { print(\"Unable to retrieve the number of rooms.\") } Apple Documentation: Optional Chaining Nil-Coalescing Operator Use the nil-coalescing operator (??) to supply a default value in case the Optional instance is nil . Here is a simple example: var optionalCar: String? = \"BMW\" print(optionalCar ?? \"There is no car\") Apple Documentation: Nil-Coalescing Operator Unconditional Unwrapping When you\u2019re certain that an instance of Optional contains a value, you can unconditionally unwrap the value by using the forced unwrap operator (postfix !). Note: Unconditionally unwrapping a nil instance with ! triggers a runtime error. Here is a simple example: var optionalCar: String? = \"BMW\" print(optionalCar!) // This code will // crash the App // var crashVariable: String? = nil // print(crashVariable!) Apple Documentation: Unconditional Unwrapping Module 6: Collection Types Start Swift provides three primary collection types , known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations. Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you can\u2019t insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection. Swift Documentation: Collection Types Arrays An array stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions. You can create an empty array of a certain type using initializer syntax. Swift\u2019s Array type also provides an initializer for creating an array of a certain size with all of its values set to the same default value. You pass this initializer a default value of the appropriate type (called repeating ): and the number of times that value is repeated in the new array (called count ): var arrayOfInts: [Int] = [] var arrayOfDoubles: [Double] = Array(repeating: 0.0, count: 3) print(arrayOfInts) print(arrayOfDoubles) Swift Documentation: Arrays You access and modify an array through its methods and properties, or by using subscript syntax. Here are some examples: var shoppingList = [\"Eggs\", \"Toast\", \"Cornflakes\"] print(\"The shopping list contains \\(shoppingList.count) items.\") if shoppingList.isEmpty { print(\"The shopping list is empty.\") } else { print(\"The shopping list isn't empty.\") } // Add shoppingList.append(\"Flour\") shoppingList += [\"Baking Powder\"] print(\"The shopping list contains \\(shoppingList)\") // Access print(\"The first item of the shopping list is: \\(shoppingList[0])\") // Modify shoppingList[0] = \"Six eggs\" print(\"The first item of the shopping list is: \\(shoppingList[0])\") // Remove let cornflakes = shoppingList.remove(at: 2) let bakingPowder = shoppingList.removeLast() Swift Documentation: Accessing and Modifying an Array You can iterate over the entire set of values in an array with the for-in loop: var shoppingList = [\"Eggs\", \"Toast\", \"Cornflakes\"] for item in shoppingList { print(item) } Swift Documentation: Iterating Over an Array Sets A set stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items isn\u2019t important, or when you need to ensure that an item only appears once. You can create an empty set of a certain type using initializer syntax: var letters = Set<Character>() print(\"letters is of type Set<Character> with \\(letters.count) items.\") // Initialize a set with an array literal var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] print(favoriteGenres) Swift Documentation: Sets You access and modify a set through its methods and properties. Here are some examples: var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] if favoriteGenres.isEmpty { print(\"As far as music goes, I'm not picky.\") } else { print(\"I have particular music preferences.\") } favoriteGenres.insert(\"Jazz\") print(favoriteGenres) if let removedGenre = favoriteGenres.remove(\"Rock\") { print(\"\\(removedGenre)? I'm over it.\") } else { print(\"I never much cared for that.\") } if favoriteGenres.contains(\"Funk\") { print(\"I get up on the good foot.\") } else { print(\"It's too funky in here.\") } Swift Documentation: Accessing and Modifying a Set You can iterate over the values in a set with a for-in loop. var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] for genre in favoriteGenres { print(\"\\(genre)\") } Swift Documentation: Iterating Over a Set You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values. Use the intersection(_:) method to create a new set with only the values common to both sets. Use the symmetricDifference(_:) method to create a new set with values in either set, but not both. Use the union(_:) method to create a new set with all of the values in both sets. Use the subtracting(_:) method to create a new set with values not in the specified set. Here's an example: let oddDigits: Set = [1, 3, 5, 7, 9] let evenDigits: Set = [0, 2, 4, 6, 8] let singleDigitPrimeNumbers: Set = [2, 3, 5, 7] let unionDigits = oddDigits .union(evenDigits) .sorted() print(unionDigits) let intersectionDigits = oddDigits .intersection(evenDigits) .sorted() print(intersectionDigits) let subtractingDigits = oddDigits .subtracting(singleDigitPrimeNumbers) .sorted() print(subtractingDigits) let symmetricDifferenceDigits = oddDigits .symmetricDifference(singleDigitPrimeNumbers) .sorted() print(symmetricDifferenceDigits) Swift Documentation: Performing Set Operations Dictionaries A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering. Each value is associated with a unique key , which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary don\u2019t have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word. As with arrays, you can create an empty Dictionary of a certain type by using initializer syntax: var namesOfIntegers: [Int: String] = [:] Swift Documentation: Dictionaries You access and modify a dictionary through its methods and properties, or by using subscript syntax. Here are some examples: var airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"] print(\"The airports dictionary contains \\(airports.count) items.\") if airports.isEmpty { print(\"The airports dictionary is empty.\") } else { print(\"The airports dictionary isn't empty.\") } // Add airports[\"LHR\"] = \"London\" // Update if let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") { print(\"The old value for DUB was \\(oldValue).\") } // Access if let airportName = airports[\"DUB\"] { print(\"The name of the airport is \\(airportName).\") } else { print(\"That airport isn't in the airports dictionary.\") } // Remove airports[\"APL\"] = \"Apple International\" // \"Apple International\" isn't the real airport for APL, so delete it airports[\"APL\"] = nil if let removedValue = airports.removeValue(forKey: \"DUB\") { print(\"The removed airport's name is \\(removedValue).\") } else { print(\"The airports dictionary doesn't contain a value for DUB.\") } Swift Documentation: Accessing and Modifying a Dictionary You can iterate over the key-value pairs in a dictionary with a for-in loop. Each item in the dictionary is returned as a (key, value) tuple, and you can decompose the tuple\u2019s members into temporary constants or variables as part of the iteration: var airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"] for (airportCode, airportName) in airports { print(\"\\(airportCode): \\(airportName)\") } Swift Documentation: Iterating Over a Dictionary Module 7: Object oriented programming Classes and Structure In Swift, classes and structures are versatile and flexible constructs that can be used to build your program\u2019s code. Both classes and structures can: Define properties to store values. Define methods to provide functionality. Define subscripts to provide access to their values using subscript syntax. Define initializers to set up their initial state. Be extended to expand their functionality beyond a default implementation. Conform to protocols to provide standard functionality of a certain kind. Swift Documentation: Classes and Structures There are also significant differences between classes and structures in Swift: Classes: 1. Inheritance: Classes can inherit from other classes. This means a class can gain the characteristics of another class. 2. Type Casting: You can check and interpret the type of a class instance at runtime. 3. Deinitializers: Classes can define deinitializers, which allow an instance of a class to free up any resources it has assigned. 4. Reference Counting: Classes are reference types and are managed by automatic reference counting (ARC). Structures: 1. No Inheritance: Structures do not support inheritance. They cannot inherit from other structures. 2. Value Types: Structures are value types. When you assign or pass around a structure, you are making a copy of it. 3. Mutability: To modify a property of a structure, you must mark it as mutating if it changes any properties of the structure within its methods. Swift Documentation: Comparing Structures and Classes Declaration Both classes and structures are declared using the class and struct keywords, respectively. Both can have properties and methods defined within them. Here\u2019s an example: struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } // create instances of structures and classes using initializer syntax: let someResolution = Resolution() let someVideoMode = VideoMode() Swift Documentation: Definition Syntax When you assign an instance of a structure to a new variable or constant, or when you pass it to a function, the instance is copied. struct Resolution { var width = 0 var height = 0 } let hd = Resolution(width: 1920, height: 1080) var cinema = hd cinema.width = 2048 print(hd.width) Swift Documentation: Structures and Enumerations Are Value Types When you assign an instance of a class to a new variable or constant, or when you pass it to a function, you are referencing the same instance. struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } let hd = Resolution(width: 1920, height: 1080) let tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = \"1080i\" tenEighty.frameRate = 25.0 let alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 print(tenEighty.frameRate) Swift Documentation: Structures and Enumerations Are Value Types Since classes are reference types, it is possible to check if two constants or variables refer to the same instance of a class using the identity operators ( === and !== ). struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } let hd = Resolution(width: 1920, height: 1080) let tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = \"1080i\" tenEighty.frameRate = 25.0 let alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 if tenEighty === alsoTenEighty { print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\") } Swift Documentation: Identity Operators Inheritance Inheritance is a mechanism in which one class (called a subclass) inherits the properties and methods of another class (called a superclass). In Swift, inheritance allows you to create a new class based on an existing class, thereby reusing code and adding new features to the existing class. Swift Documentation: Inheritance A base class is any class that doesn\u2019t inherit from another class. Subclassing is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass. To create a subclass, you specify the subclass's name before the superclass's name, separated by a colon. The example below defines a base class called Vehicle . This base class defines a stored property called currentSpeed , with a default value of 0.0 (inferring a property type of Double ). The currentSpeed property\u2019s value is used by a read-only computed String property calle description to create a description of the vehicle. The Vehicle base class also defines a method called makeNoise . This method doesn\u2019t actually do anything for a base Vehicle instance. Bicycle is a subclass of Vehicle . It inherits all properties and methods from Vehicle , and also introduces a new property hasBasket . class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Bicycle: Vehicle { var hasBasket = false } let bicycle = Bicycle() print(bicycle.description) Swift Documentation: Defining a Base Class You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass. The following example defines a new subclass of Vehicle called Train , which overrides the makeNoise() method that Train inherits from Vehicle : class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Train: Vehicle { override func makeNoise() { print(\"Choo Choo\") } } let train = Train() print(train.makeNoise()) [Swift Documentation: Overriding Methods](https://docs.swift .org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Methods) You can also override properties, including computed properties, to modify their behavior or provide custom getters and setters. Here, the Car class overrides the description property of its superclass Vehicle to add information about the car\u2019s gear. class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Car: Vehicle { var gear = 1 override var description: String { return super.description + \" in gear \\(gear)\" } } let car = Car() print(car.description) Swift Documentation: Overriding Properties You can prevent a method, property, or subscript from being overridden by marking it as final . Do this by writing the final modifier before the method, property, or subscript\u2019s introducer keyword (such as final var , final func , final class func , and final subscript ). If you try to subclass Train or override its methods or properties, Swift will generate a compile-time error. final class Train: Vehicle { override func makeNoise() { print(\"Choo Choo\") } } Swift Documentation: Preventing Overrides Protocols A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. Classes, structures, and enumerations can adopt protocols and provide implementations for the requirements defined in those protocols. Swift Documentation: Protocols In this example, SomeProtocol defines an instance property requirement ( mustBeSettable and doesNotNeedToBeSettable ), a type property requirement ( someTypeProperty ), an instance method requirement ( someMethod ), a mutating instance method requirement ( changeSomething ), and a type method requirement ( someTypeMethod ). protocol SomeProtocol { var mustBeSettable: Int { get set } var doesNotNeedToBeSettable: Int { get } static var someTypeProperty: Int { get set } func someMethod() mutating func changeSomething() static func someTypeMethod() } Swift Documentation: Defining Protocols A protocol can require any conforming type to provide an instance property or instance method with a particular name and type. The protocol does not specify whether the property should be a stored property or a computed property. It only specifies the required property name and type. protocol FullyNamed { var fullName: String { get } } struct Person: FullyNamed { var fullName: String } let john = Person(fullName: \"John Appleseed\") print(john.fullName) Swift Documentation: Property Requirements A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits. protocol InheritingProtocol: SomeProtocol, AnotherProtocol { // additional requirements go here } Swift Documentation: Protocol Inheritance You can combine multiple protocols into a single requirement using a protocol composition. protocol Named { var name: String { get } } protocol Aged { var age: Int { get } } struct Person: Named, Aged { var name: String var age: Int } func wishHappyBirthday(to celebrator: Named & Aged) { print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\") } let birthdayPerson = Person(name: \"John\", age: 21) wishHappyBirthday(to: birthdayPerson) Swift Documentation: Protocol Composition Extensions Extensions add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling). Swift Documentation: Extensions Declare extensions with the extension keyword: Extensions can add computed instance properties, computed type properties, and new methods to existing types. extension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } func printCurrentValue() { print(\"The current value is \\(self)\") } } let number = 25.4 print(\"One inch is \\(number.mm) meters\") number.printCurrentValue() Swift Documentation: Extension Syntax Instance methods added with an extension can also modify (or mutate ) the instance itself. Structure and enumeration methods that modify self or its properties must mark the instance method as mutating , just like mutating methods from an original implementation. The example below adds a new mutating method called square to Swift\u2019s Int type, which squares the original value: extension Int { mutating func square() { self = self * self } } var someInt = 3 someInt.square() print(someInt) Swift Documentation: Mutating Instance Methods Module 8: Error Handling Start Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime. Some operations aren\u2019t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it\u2019s often useful to understand what caused the failure, so that your code can respond accordingly. As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can\u2019t resolve. Swift Documentation: Error Handling Representing / Throwing Errors In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling. Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here\u2019s how you might represent the error conditions of operating a vending machine inside a game: enum VendingMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case outOfStock } Swift Documentation: Representing and Throwing Errors Handling Errors There are four ways to handle errors in Swift: Propagating Errors Using throws A function or method that can throw an error must be marked with the throws keyword. When calling this function, you must handle the error using a try keyword. Do-Catch You can handle errors using a do-catch block. Inside the do block, you use try to call functions that can throw errors. In the catch blocks, you handle the errors. Optional Try? You can convert an error to an optional value using try? . If an error is thrown, the expression evaluates to nil . Force Try! You can disable error propagation using try! , which will cause a runtime error if an error is thrown. Here are some examples: enum DivisionError: Error { case divisionByZero } // 1. func divide(_ numerator: Double, by denominator: Double) throws -> Double { if denominator == 0 { throw DivisionError.divisionByZero } return numerator / denominator } // 2. do { let result = try divide(10, by: 2) print(\"Result: \\(result)\") // This will print: Result: 5.0 } catch DivisionError.divisionByZero { print(\"Error: Division by zero.\") } // 3. if let result = try? divide(10, by: 2) { print(\"Result: \\(result)\") // This will print: Result: 5.0 } else { print(\"Error: Division by zero.\") } // 4. let result = try! divide(10, by: 2) print(\"Result: \\(result)\") // This will print: Result: 5.0 Swift Documentation: Propagating Errors Using Throws Level Advanced Module 9: Functional Programming Closures Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages. Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables. Here\u2019s an example of a closure that captures values from its surrounding context: let incrementByTwo = { (number: Int) -> Int in return number + 2 } let result = incrementByTwo(3) print(result) // This will print: 5 Swift Documentation: Closures Swift provides several optimizations for closure expressions: Inferring Parameter and Return Types from Context Implicit Returns from Single-Expression Closures Shorthand Argument Names Trailing Closures Here\u2019s an example of a shorthand closure expression: let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"] let reversedNames = names.sorted(by: { $0 > $1 }) print(reversedNames) // This will print: [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"] Swift Documentation: Closure Expression Syntax Generics Generics are a powerful feature of Swift that allow you to write flexible and reusable functions and types. Generic code enables you to write functions and types that can work with any type, subject to requirements that you define. Here\u2019s a generic function that swaps the values of two variables: func swapTwoValues<T>(_ a: inout T, _ b: inout T) { let temporaryA = a a = b b = temporaryA } var a = 5 var b = 10 swapTwoValues(&a, &b) print(\"a is now \\(a), and b is now \\(b)\") Swift Documentation: Generics Module 10: Advanced Swift-Lectures Property Observers Property observers observe and respond to changes in a property\u2019s value. Property observers are called every time a property\u2019s value is set, even if the new value is the same as the property\u2019s current value. You can add property observers to any stored properties you define, except for lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass. Here\u2019s an example: class StepCounter { var totalSteps: Int = 0 { willSet(newTotalSteps) { print(\"About to set totalSteps to \\(newTotalSteps)\") } didSet { if totalSteps > oldValue { print(\"Added \\(totalSteps - oldValue) steps\") } } } } let stepCounter = StepCounter() stepCounter.totalSteps = 200 stepCounter.totalSteps = 360 stepCounter.totalSteps = 896 Swift Documentation: Property Observers Type Casting Type casting is a way to check the type of an instance, and/or to treat that instance as if it is a different superclass or subclass from somewhere else in its own class hierarchy. Type casting in Swift is implemented with the is and as operators. You can use these operators to check the type of a value or cast a value to a different type. Here\u2019s an example: class MediaItem { var name: String init(name: String) { self.name = name } } class Movie: MediaItem { var director: String init(name: String, director: String) { self.director = director super.init(name: name) } } class Song: MediaItem { var artist: String init(name: String, artist: String) { self.artist = artist super.init(name: name) } } let library = [ Movie(name: \"Casablanca\", director: \"Michael Curtiz\"), Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"), Movie(name: \"Citizen Kane\", director: \"Orson Welles\"), Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"), Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\") ] var movieCount = 0 var songCount = 0 for item in library { if item is Movie { movieCount += 1 } else if item is Song { songCount += 1 } } print(\"Media library contains \\(movieCount) movies and \\(songCount) songs\") Swift Documentation: Type Casting","title":"Swift"},{"location":"swift/#learn-swift","text":"","title":"Learn Swift"},{"location":"swift/#table-of-contents","text":"Beginner Module 1: Introduction to Swift Swift Basics Comments in Swift Module 2: Basic concepts in Swift Introduction Type Annotations Integers and Floating-Points Strings and Characters Booleans Operators Enumerations Module 3: Control Flows Conditionals Loops Control Transfers Module 4: Functions Introduction Specify Argument and Parameters Function Types Intermediate Module 5: Optionals Theory Binding Chaining Nil-Coalescing Operator Unconditional Unwrapping Module 6: Collection Types Start Arrays Sets Dictionaries Module 7: Object oriented programming Classes and Structure Declaration Inheritance Protocols Extensions Module 8: Error Handling Start Representing / Throwing Errors Handling Errors Advanced Module 9: Functional Programming Closures Generics Module 10: Advanced Swift-Lectures Property Observers Type Casting","title":"Table of contents"},{"location":"swift/#level-beginners","text":"","title":"Level Beginners"},{"location":"swift/#module-1-introduction-to-swift","text":"","title":"Module 1: Introduction to Swift"},{"location":"swift/#swift-basics","text":"A variable can be created using the keyword var . Constants can be created using let . To print the value out, use the function print() . Unlike other languages like C or C++, you don't need to specify the data type. The compiler recognizes the data types automatically. In the next module, you will learn about different data types. var variable1 = 0 let constant = 1 print(variable1) print(constant) variable1 = 5 print(variable1) // Compiler-Error // constant = 10 Swift Documentation: The Basics","title":"Swift Basics"},{"location":"swift/#comments-in-swift","text":"Use comments to include nonexecutable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled. Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes ( // ). Multiline comments start with a forward-slash followed by an asterisk ( /* ) and end with an asterisk followed by a forward-slash ( */ ): // This is a comment /* This is also a comment but is written over multiple lines. */ Swift Documentation: Comments","title":"Comments in Swift"},{"location":"swift/#module-2-basic-concepts-in-swift","text":"","title":"Module 2: Basic concepts in Swift"},{"location":"swift/#introduction","text":"Constants and variables must be declared before they\u2019re used. You declare constants with the let keyword and variables with the var keyword. Here\u2019s an example of how constants and variables can be used to track the number of login attempts a user has made. The result will get with print printed out. Use String Interpolation ( \\( ) ) to print out the variable in a String . let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 print(\"The maximum number of login attempts is \\(maximumNumberOfLoginAttempts)\") print(\"The current number of login attempts is \\(currentLoginAttempt)\") Swift Documentation: Declaring Constants and Variables","title":"Introduction"},{"location":"swift/#type-annotations","text":"You can provide a type annotation when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use. This example provides a type annotation for a variable called welcomeMessage , to indicate that the variable can store String values: var welcomeMessage: String // The welcomeMessage variable can now be set to any string value without error: welcomeMessage = \"Hello\" print(welcomeMessage) Swift Documentation: Type Annotations","title":"Type Annotations"},{"location":"swift/#integers-and-floating-points","text":"Integers are whole numbers with no fractional component, such as 42 and -23. Integers are either signed (positive, zero, or negative) or unsigned (positive or zero). Floating-point numbers are numbers with a fractional component, such as 3.14159, 0.1, and -273.15. Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an Int. Swift provides two signed floating-point number types: Double represents a 64-bit floating-point number. Float represents a 32-bit floating-point number. Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, Double is preferred. let age = 12 // int let note = 1.7 // double print(age) print(note) Swift Documentation: Int","title":"Integers and Floating-Points"},{"location":"swift/#strings-and-characters","text":"A string is a series of characters, such as \"hello, world\" or \"albatross\". Swift strings are represented by the String type. The contents of a String can be accessed in various ways, including as a collection of Character values. You can include predefined String values within your code as string literals. A string literal is a sequence of characters surrounded by double quotation marks (\"\"). Use a string literal as an initial value for a constant or variable: let someString = \"Some string literal value\" print(someString) Swift Documentation: String Literals","title":"Strings and Characters"},{"location":"swift/#booleans","text":"Swift has a basic Boolean type, called Bool . Boolean values are referred to as logical, because they can only ever be true or false . let orangesAreOrange = true let turnipsAreDelicious = false print(orangesAreOrange) print(turnipsAreDelicious) Swift Documentation: Booleans","title":"Booleans"},{"location":"swift/#operators","text":"Operators are unary, binary, or ternary: Unary operators operate on a single target (such as -a ). Unary prefix operators appear immediately before their target (such as !b ), and unary postfix operators appear immediately after their target (such as c! ). Binary operators operate on two targets (such as `2 + 3 ) and are infix because they appear in between their two targets. - Ternary operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator ( a ? b : c`). The values that operators affect are operands. In the expression 1 + 2 , the + symbol is an infix operator and its two operands are the values 1 and 2. // Unary Operators: -a // Binary Operators: 2 + 3 // Ternary Operators: a ? b : c Swift Documentation: Terminology","title":"Operators"},{"location":"swift/#enumerations","text":"Enumerations (or enums ) in Swift are a powerful feature that allows you to define a common type for a group of related values and work with those values in a type-safe way. Swift enumerations are more flexible than their counterparts in many other languages. They can have associated values and methods. enum CompassPoint { case north case south case east case west } // or enum CompassPointVariant2 { case north, south, east, west } Swift Documentation: Enumeration Syntax","title":"Enumerations"},{"location":"swift/#module-3-control-flows","text":"","title":"Module 3: Control Flows"},{"location":"swift/#conditionals","text":"It\u2019s often useful to execute different pieces of code based on certain conditions. You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low. To do this, you make parts of your code conditional. Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute. if <statement> { // do something } switch <some value> { case <Nr. 1>: // do something case <Nr. 2>: // do something default: // do something } Swift Documentation: Control Flow","title":"Conditionals"},{"location":"swift/#loops","text":"You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string. Here are some examples: // Iterate over the items in an array let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] for name in names { print(\"Hello, \\(name)!\") } // Iterate over a range of numbers from 1 to 5 for index in 1...5 { print(\"\\(index)! times 5 is \\(index * 5)!\") } // the half-open range operator (..<) includes the // lower bound but not the upper bound. // 1..<6 is equal to 1...5 // If you don\u2019t need each value from a sequence, // you can ignore the values by using an underscore // in place of a variable name. for _ in 1...5 { print(\"Loops are cool\") } Swift Documentation: For-In Loops","title":"Loops"},{"location":"swift/#control-transfers","text":"Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue break fallthrough return throw The continue , break , and fallthrough statements are described below. The return statement is described in Module: Functions , and the throw statement is described in Module: Error Handling . for number in 1...10 { if number % 2 == 0 { continue } print(number) } for number in 1...10 { if number == 5 { break } print(number) } let number = 3 switch number { case 1: print(\"The number is 1\") case 2: print(\"The number is 2\") case 3: print(\"The number is 3\") fallthrough // Continue to the next case case 4: print(\"The number is 4\") fallthrough // Continue to the next case case 5: print(\"The number is 5\") default: print(\"The number is something else\") } Swift Documentation: Control Transfer Statements","title":"Control Transfers"},{"location":"swift/#module-4-functions","text":"","title":"Module 4: Functions"},{"location":"swift/#introduction_1","text":"When defining a function , you can optionally define named, typed input values called parameters , and a type for the output value, known as the return type. Every function has a name describing its task. To use a function, you \"call\" it with its name and provide input values, or arguments, matching the function\u2019s parameters in the specified order. To demonstrate this, there are two functions: The function greet(person:) , takes a person\u2019s name as input and returns a greeting. It defines one input parameter\u2014a String called person\u2014and a return type of String for the greeting. The function helloWorld() takes no parameters and returns nothing; it only prints \"Hello World\". func greet(person: String) -> String { let greeting = \"Hello, \" + person + \"!\" return greeting } func helloWorld() { print(\"Hello World\") } print(greet(person: \"Anna\")) print(greet(person: \"Brian\")) helloWorld() Swift Documentation: Defining and Calling Functions","title":"Introduction"},{"location":"swift/#specify-argument-and-parameters","text":"Each function parameter has both an argument label and a parameter name . The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label. You can specify an argument label before the parameter name, separated by a space. Here\u2019s a variation of the greet(person:) function that takes a person\u2019s name and hometown and returns a greeting: func greet(person: String, from hometown: String) -> String { return \"Hello \\(person)! Glad you could visit from \\(hometown).\" } print(greet(person: \"Bill\", from: \"Cupertino\")) Swift Documentation: Function Argument Labels and Parameter Names","title":"Specify Argument and Parameters"},{"location":"swift/#function-types","text":"Every function has a specific function type , made up of the parameter types and the return type of the function. For example: func addTwoInts(_ a: Int, _ b: Int) -> Int { return a + b } func multiplyTwoInts(_ a: Int, _ b: Int) -> Int { return a * b } func printHelloWorld() { print(\"hello, world\") } The type of both of these functions is: (Int, Int) -> Int This can be read as: \u201cA function that has two parameters, both of type Int, and that returns a value of type Int.\u201d Here\u2019s another example, for a function with no parameters or return value: func printHelloWorld() { print(\"hello, world\") } The type of this function is () -> Void , or \u201ca function that has no parameters, and returns Void.\u201d Swift Documentation: Function Types","title":"Function Types"},{"location":"swift/#level-intermediate","text":"","title":"Level Intermediate"},{"location":"swift/#module-5-optionals","text":"","title":"Module 5: Optionals"},{"location":"swift/#theory","text":"Optionals are a fundamental feature in Swift. They allow you to declare variables or constants that can either hold a value or be nil (no value). Swift\u2019s type system usually shows the wrapped type\u2019s name with a trailing question mark (?) instead of showing the full type name. For example, if a variable has the type Int? , that\u2019s just another way of writing Optional<Int> . var ageShort: Int? var ageLong: Optional<Int> Apple Documentation: Optional","title":"Theory"},{"location":"swift/#binding","text":"To conditionally bind the wrapped value of an Optional instance to a new variable, use one of the optional binding control structures, including if let , guard let , and switch . Here are some examples: var age: Int? = nil if let unwrappedAge = age { print(unwrappedAge) } else { print(\"Age is nil\") } var name: String? = \"Max\" guard let unwrappedName = name else { print(\"Name is nil\") return } print(unwrappedName) Apple Documentation: Optional Binding","title":"Binding"},{"location":"swift/#chaining","text":"To safely access the properties and methods of a wrapped instance, use the postfix optional chaining operator (postfix ? ). Here is an example (You will learn classes in the Module 7: Object Oriented Programming ): class Person { var residence: Residence? } class Residence { var numberOfRooms = 1 } let john = Person() if let roomCount = john.residence?.numberOfRooms { print(\"John's residence has \\(roomCount) room(s).\") } else { print(\"Unable to retrieve the number of rooms.\") } Apple Documentation: Optional Chaining","title":"Chaining"},{"location":"swift/#nil-coalescing-operator","text":"Use the nil-coalescing operator (??) to supply a default value in case the Optional instance is nil . Here is a simple example: var optionalCar: String? = \"BMW\" print(optionalCar ?? \"There is no car\") Apple Documentation: Nil-Coalescing Operator","title":"Nil-Coalescing Operator"},{"location":"swift/#unconditional-unwrapping","text":"When you\u2019re certain that an instance of Optional contains a value, you can unconditionally unwrap the value by using the forced unwrap operator (postfix !). Note: Unconditionally unwrapping a nil instance with ! triggers a runtime error. Here is a simple example: var optionalCar: String? = \"BMW\" print(optionalCar!) // This code will // crash the App // var crashVariable: String? = nil // print(crashVariable!) Apple Documentation: Unconditional Unwrapping","title":"Unconditional Unwrapping"},{"location":"swift/#module-6-collection-types","text":"","title":"Module 6: Collection Types"},{"location":"swift/#start","text":"Swift provides three primary collection types , known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations. Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you can\u2019t insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection. Swift Documentation: Collection Types","title":"Start"},{"location":"swift/#arrays","text":"An array stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions. You can create an empty array of a certain type using initializer syntax. Swift\u2019s Array type also provides an initializer for creating an array of a certain size with all of its values set to the same default value. You pass this initializer a default value of the appropriate type (called repeating ): and the number of times that value is repeated in the new array (called count ): var arrayOfInts: [Int] = [] var arrayOfDoubles: [Double] = Array(repeating: 0.0, count: 3) print(arrayOfInts) print(arrayOfDoubles) Swift Documentation: Arrays You access and modify an array through its methods and properties, or by using subscript syntax. Here are some examples: var shoppingList = [\"Eggs\", \"Toast\", \"Cornflakes\"] print(\"The shopping list contains \\(shoppingList.count) items.\") if shoppingList.isEmpty { print(\"The shopping list is empty.\") } else { print(\"The shopping list isn't empty.\") } // Add shoppingList.append(\"Flour\") shoppingList += [\"Baking Powder\"] print(\"The shopping list contains \\(shoppingList)\") // Access print(\"The first item of the shopping list is: \\(shoppingList[0])\") // Modify shoppingList[0] = \"Six eggs\" print(\"The first item of the shopping list is: \\(shoppingList[0])\") // Remove let cornflakes = shoppingList.remove(at: 2) let bakingPowder = shoppingList.removeLast() Swift Documentation: Accessing and Modifying an Array You can iterate over the entire set of values in an array with the for-in loop: var shoppingList = [\"Eggs\", \"Toast\", \"Cornflakes\"] for item in shoppingList { print(item) } Swift Documentation: Iterating Over an Array","title":"Arrays"},{"location":"swift/#sets","text":"A set stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items isn\u2019t important, or when you need to ensure that an item only appears once. You can create an empty set of a certain type using initializer syntax: var letters = Set<Character>() print(\"letters is of type Set<Character> with \\(letters.count) items.\") // Initialize a set with an array literal var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] print(favoriteGenres) Swift Documentation: Sets You access and modify a set through its methods and properties. Here are some examples: var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] if favoriteGenres.isEmpty { print(\"As far as music goes, I'm not picky.\") } else { print(\"I have particular music preferences.\") } favoriteGenres.insert(\"Jazz\") print(favoriteGenres) if let removedGenre = favoriteGenres.remove(\"Rock\") { print(\"\\(removedGenre)? I'm over it.\") } else { print(\"I never much cared for that.\") } if favoriteGenres.contains(\"Funk\") { print(\"I get up on the good foot.\") } else { print(\"It's too funky in here.\") } Swift Documentation: Accessing and Modifying a Set You can iterate over the values in a set with a for-in loop. var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"] for genre in favoriteGenres { print(\"\\(genre)\") } Swift Documentation: Iterating Over a Set You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values. Use the intersection(_:) method to create a new set with only the values common to both sets. Use the symmetricDifference(_:) method to create a new set with values in either set, but not both. Use the union(_:) method to create a new set with all of the values in both sets. Use the subtracting(_:) method to create a new set with values not in the specified set. Here's an example: let oddDigits: Set = [1, 3, 5, 7, 9] let evenDigits: Set = [0, 2, 4, 6, 8] let singleDigitPrimeNumbers: Set = [2, 3, 5, 7] let unionDigits = oddDigits .union(evenDigits) .sorted() print(unionDigits) let intersectionDigits = oddDigits .intersection(evenDigits) .sorted() print(intersectionDigits) let subtractingDigits = oddDigits .subtracting(singleDigitPrimeNumbers) .sorted() print(subtractingDigits) let symmetricDifferenceDigits = oddDigits .symmetricDifference(singleDigitPrimeNumbers) .sorted() print(symmetricDifferenceDigits) Swift Documentation: Performing Set Operations","title":"Sets"},{"location":"swift/#dictionaries","text":"A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering. Each value is associated with a unique key , which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary don\u2019t have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word. As with arrays, you can create an empty Dictionary of a certain type by using initializer syntax: var namesOfIntegers: [Int: String] = [:] Swift Documentation: Dictionaries You access and modify a dictionary through its methods and properties, or by using subscript syntax. Here are some examples: var airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"] print(\"The airports dictionary contains \\(airports.count) items.\") if airports.isEmpty { print(\"The airports dictionary is empty.\") } else { print(\"The airports dictionary isn't empty.\") } // Add airports[\"LHR\"] = \"London\" // Update if let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") { print(\"The old value for DUB was \\(oldValue).\") } // Access if let airportName = airports[\"DUB\"] { print(\"The name of the airport is \\(airportName).\") } else { print(\"That airport isn't in the airports dictionary.\") } // Remove airports[\"APL\"] = \"Apple International\" // \"Apple International\" isn't the real airport for APL, so delete it airports[\"APL\"] = nil if let removedValue = airports.removeValue(forKey: \"DUB\") { print(\"The removed airport's name is \\(removedValue).\") } else { print(\"The airports dictionary doesn't contain a value for DUB.\") } Swift Documentation: Accessing and Modifying a Dictionary You can iterate over the key-value pairs in a dictionary with a for-in loop. Each item in the dictionary is returned as a (key, value) tuple, and you can decompose the tuple\u2019s members into temporary constants or variables as part of the iteration: var airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"] for (airportCode, airportName) in airports { print(\"\\(airportCode): \\(airportName)\") } Swift Documentation: Iterating Over a Dictionary","title":"Dictionaries"},{"location":"swift/#module-7-object-oriented-programming","text":"","title":"Module 7: Object oriented programming"},{"location":"swift/#classes-and-structure","text":"In Swift, classes and structures are versatile and flexible constructs that can be used to build your program\u2019s code. Both classes and structures can: Define properties to store values. Define methods to provide functionality. Define subscripts to provide access to their values using subscript syntax. Define initializers to set up their initial state. Be extended to expand their functionality beyond a default implementation. Conform to protocols to provide standard functionality of a certain kind. Swift Documentation: Classes and Structures There are also significant differences between classes and structures in Swift: Classes: 1. Inheritance: Classes can inherit from other classes. This means a class can gain the characteristics of another class. 2. Type Casting: You can check and interpret the type of a class instance at runtime. 3. Deinitializers: Classes can define deinitializers, which allow an instance of a class to free up any resources it has assigned. 4. Reference Counting: Classes are reference types and are managed by automatic reference counting (ARC). Structures: 1. No Inheritance: Structures do not support inheritance. They cannot inherit from other structures. 2. Value Types: Structures are value types. When you assign or pass around a structure, you are making a copy of it. 3. Mutability: To modify a property of a structure, you must mark it as mutating if it changes any properties of the structure within its methods. Swift Documentation: Comparing Structures and Classes","title":"Classes and Structure"},{"location":"swift/#declaration","text":"Both classes and structures are declared using the class and struct keywords, respectively. Both can have properties and methods defined within them. Here\u2019s an example: struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } // create instances of structures and classes using initializer syntax: let someResolution = Resolution() let someVideoMode = VideoMode() Swift Documentation: Definition Syntax When you assign an instance of a structure to a new variable or constant, or when you pass it to a function, the instance is copied. struct Resolution { var width = 0 var height = 0 } let hd = Resolution(width: 1920, height: 1080) var cinema = hd cinema.width = 2048 print(hd.width) Swift Documentation: Structures and Enumerations Are Value Types When you assign an instance of a class to a new variable or constant, or when you pass it to a function, you are referencing the same instance. struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } let hd = Resolution(width: 1920, height: 1080) let tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = \"1080i\" tenEighty.frameRate = 25.0 let alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 print(tenEighty.frameRate) Swift Documentation: Structures and Enumerations Are Value Types Since classes are reference types, it is possible to check if two constants or variables refer to the same instance of a class using the identity operators ( === and !== ). struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } let hd = Resolution(width: 1920, height: 1080) let tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = \"1080i\" tenEighty.frameRate = 25.0 let alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 if tenEighty === alsoTenEighty { print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\") } Swift Documentation: Identity Operators","title":"Declaration"},{"location":"swift/#inheritance","text":"Inheritance is a mechanism in which one class (called a subclass) inherits the properties and methods of another class (called a superclass). In Swift, inheritance allows you to create a new class based on an existing class, thereby reusing code and adding new features to the existing class. Swift Documentation: Inheritance A base class is any class that doesn\u2019t inherit from another class. Subclassing is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass. To create a subclass, you specify the subclass's name before the superclass's name, separated by a colon. The example below defines a base class called Vehicle . This base class defines a stored property called currentSpeed , with a default value of 0.0 (inferring a property type of Double ). The currentSpeed property\u2019s value is used by a read-only computed String property calle description to create a description of the vehicle. The Vehicle base class also defines a method called makeNoise . This method doesn\u2019t actually do anything for a base Vehicle instance. Bicycle is a subclass of Vehicle . It inherits all properties and methods from Vehicle , and also introduces a new property hasBasket . class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Bicycle: Vehicle { var hasBasket = false } let bicycle = Bicycle() print(bicycle.description) Swift Documentation: Defining a Base Class You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass. The following example defines a new subclass of Vehicle called Train , which overrides the makeNoise() method that Train inherits from Vehicle : class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Train: Vehicle { override func makeNoise() { print(\"Choo Choo\") } } let train = Train() print(train.makeNoise()) [Swift Documentation: Overriding Methods](https://docs.swift .org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Methods) You can also override properties, including computed properties, to modify their behavior or provide custom getters and setters. Here, the Car class overrides the description property of its superclass Vehicle to add information about the car\u2019s gear. class Vehicle { var currentSpeed = 0.0 var description: String { return \"traveling at \\(currentSpeed) miles per hour\" } func makeNoise() { // do nothing - an arbitrary vehicle doesn't necessarily make a noise } } class Car: Vehicle { var gear = 1 override var description: String { return super.description + \" in gear \\(gear)\" } } let car = Car() print(car.description) Swift Documentation: Overriding Properties You can prevent a method, property, or subscript from being overridden by marking it as final . Do this by writing the final modifier before the method, property, or subscript\u2019s introducer keyword (such as final var , final func , final class func , and final subscript ). If you try to subclass Train or override its methods or properties, Swift will generate a compile-time error. final class Train: Vehicle { override func makeNoise() { print(\"Choo Choo\") } } Swift Documentation: Preventing Overrides","title":"Inheritance"},{"location":"swift/#protocols","text":"A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. Classes, structures, and enumerations can adopt protocols and provide implementations for the requirements defined in those protocols. Swift Documentation: Protocols In this example, SomeProtocol defines an instance property requirement ( mustBeSettable and doesNotNeedToBeSettable ), a type property requirement ( someTypeProperty ), an instance method requirement ( someMethod ), a mutating instance method requirement ( changeSomething ), and a type method requirement ( someTypeMethod ). protocol SomeProtocol { var mustBeSettable: Int { get set } var doesNotNeedToBeSettable: Int { get } static var someTypeProperty: Int { get set } func someMethod() mutating func changeSomething() static func someTypeMethod() } Swift Documentation: Defining Protocols A protocol can require any conforming type to provide an instance property or instance method with a particular name and type. The protocol does not specify whether the property should be a stored property or a computed property. It only specifies the required property name and type. protocol FullyNamed { var fullName: String { get } } struct Person: FullyNamed { var fullName: String } let john = Person(fullName: \"John Appleseed\") print(john.fullName) Swift Documentation: Property Requirements A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits. protocol InheritingProtocol: SomeProtocol, AnotherProtocol { // additional requirements go here } Swift Documentation: Protocol Inheritance You can combine multiple protocols into a single requirement using a protocol composition. protocol Named { var name: String { get } } protocol Aged { var age: Int { get } } struct Person: Named, Aged { var name: String var age: Int } func wishHappyBirthday(to celebrator: Named & Aged) { print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\") } let birthdayPerson = Person(name: \"John\", age: 21) wishHappyBirthday(to: birthdayPerson) Swift Documentation: Protocol Composition","title":"Protocols"},{"location":"swift/#extensions","text":"Extensions add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling). Swift Documentation: Extensions Declare extensions with the extension keyword: Extensions can add computed instance properties, computed type properties, and new methods to existing types. extension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } func printCurrentValue() { print(\"The current value is \\(self)\") } } let number = 25.4 print(\"One inch is \\(number.mm) meters\") number.printCurrentValue() Swift Documentation: Extension Syntax Instance methods added with an extension can also modify (or mutate ) the instance itself. Structure and enumeration methods that modify self or its properties must mark the instance method as mutating , just like mutating methods from an original implementation. The example below adds a new mutating method called square to Swift\u2019s Int type, which squares the original value: extension Int { mutating func square() { self = self * self } } var someInt = 3 someInt.square() print(someInt) Swift Documentation: Mutating Instance Methods","title":"Extensions"},{"location":"swift/#module-8-error-handling","text":"","title":"Module 8: Error Handling"},{"location":"swift/#start_1","text":"Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime. Some operations aren\u2019t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it\u2019s often useful to understand what caused the failure, so that your code can respond accordingly. As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can\u2019t resolve. Swift Documentation: Error Handling","title":"Start"},{"location":"swift/#representing-throwing-errors","text":"In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling. Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here\u2019s how you might represent the error conditions of operating a vending machine inside a game: enum VendingMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case outOfStock } Swift Documentation: Representing and Throwing Errors","title":"Representing / Throwing Errors"},{"location":"swift/#handling-errors","text":"There are four ways to handle errors in Swift: Propagating Errors Using throws A function or method that can throw an error must be marked with the throws keyword. When calling this function, you must handle the error using a try keyword. Do-Catch You can handle errors using a do-catch block. Inside the do block, you use try to call functions that can throw errors. In the catch blocks, you handle the errors. Optional Try? You can convert an error to an optional value using try? . If an error is thrown, the expression evaluates to nil . Force Try! You can disable error propagation using try! , which will cause a runtime error if an error is thrown. Here are some examples: enum DivisionError: Error { case divisionByZero } // 1. func divide(_ numerator: Double, by denominator: Double) throws -> Double { if denominator == 0 { throw DivisionError.divisionByZero } return numerator / denominator } // 2. do { let result = try divide(10, by: 2) print(\"Result: \\(result)\") // This will print: Result: 5.0 } catch DivisionError.divisionByZero { print(\"Error: Division by zero.\") } // 3. if let result = try? divide(10, by: 2) { print(\"Result: \\(result)\") // This will print: Result: 5.0 } else { print(\"Error: Division by zero.\") } // 4. let result = try! divide(10, by: 2) print(\"Result: \\(result)\") // This will print: Result: 5.0 Swift Documentation: Propagating Errors Using Throws","title":"Handling Errors"},{"location":"swift/#level-advanced","text":"","title":"Level Advanced"},{"location":"swift/#module-9-functional-programming","text":"","title":"Module 9: Functional Programming"},{"location":"swift/#closures","text":"Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages. Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables. Here\u2019s an example of a closure that captures values from its surrounding context: let incrementByTwo = { (number: Int) -> Int in return number + 2 } let result = incrementByTwo(3) print(result) // This will print: 5 Swift Documentation: Closures Swift provides several optimizations for closure expressions: Inferring Parameter and Return Types from Context Implicit Returns from Single-Expression Closures Shorthand Argument Names Trailing Closures Here\u2019s an example of a shorthand closure expression: let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"] let reversedNames = names.sorted(by: { $0 > $1 }) print(reversedNames) // This will print: [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"] Swift Documentation: Closure Expression Syntax","title":"Closures"},{"location":"swift/#generics","text":"Generics are a powerful feature of Swift that allow you to write flexible and reusable functions and types. Generic code enables you to write functions and types that can work with any type, subject to requirements that you define. Here\u2019s a generic function that swaps the values of two variables: func swapTwoValues<T>(_ a: inout T, _ b: inout T) { let temporaryA = a a = b b = temporaryA } var a = 5 var b = 10 swapTwoValues(&a, &b) print(\"a is now \\(a), and b is now \\(b)\") Swift Documentation: Generics","title":"Generics"},{"location":"swift/#module-10-advanced-swift-lectures","text":"","title":"Module 10: Advanced Swift-Lectures"},{"location":"swift/#property-observers","text":"Property observers observe and respond to changes in a property\u2019s value. Property observers are called every time a property\u2019s value is set, even if the new value is the same as the property\u2019s current value. You can add property observers to any stored properties you define, except for lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass. Here\u2019s an example: class StepCounter { var totalSteps: Int = 0 { willSet(newTotalSteps) { print(\"About to set totalSteps to \\(newTotalSteps)\") } didSet { if totalSteps > oldValue { print(\"Added \\(totalSteps - oldValue) steps\") } } } } let stepCounter = StepCounter() stepCounter.totalSteps = 200 stepCounter.totalSteps = 360 stepCounter.totalSteps = 896 Swift Documentation: Property Observers","title":"Property Observers"},{"location":"swift/#type-casting","text":"Type casting is a way to check the type of an instance, and/or to treat that instance as if it is a different superclass or subclass from somewhere else in its own class hierarchy. Type casting in Swift is implemented with the is and as operators. You can use these operators to check the type of a value or cast a value to a different type. Here\u2019s an example: class MediaItem { var name: String init(name: String) { self.name = name } } class Movie: MediaItem { var director: String init(name: String, director: String) { self.director = director super.init(name: name) } } class Song: MediaItem { var artist: String init(name: String, artist: String) { self.artist = artist super.init(name: name) } } let library = [ Movie(name: \"Casablanca\", director: \"Michael Curtiz\"), Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"), Movie(name: \"Citizen Kane\", director: \"Orson Welles\"), Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"), Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\") ] var movieCount = 0 var songCount = 0 for item in library { if item is Movie { movieCount += 1 } else if item is Song { songCount += 1 } } print(\"Media library contains \\(movieCount) movies and \\(songCount) songs\") Swift Documentation: Type Casting","title":"Type Casting"},{"location":"swiftQuiz/","text":"Quizzes for Swift Table of contents Beginner Module 1: Introduction to Swift Quiz 1: Create a constant Quiz 2: Learn comments Module 2: Basic concepts in Swift Quiz 1: Declare a variable Quiz 2: Learn Operators Module 3: Control Flows Quiz 1: Learn if-else Quiz 2: Learn switch Quiz 3: Learn for-loops Quiz 4: Learn while-loops Quiz 5: Learn repeat-while-loops Quiz 6: Learn continue Quiz 7: Learn break Quiz 8: Learn fallthrough Module 4: Functions Quiz 1: Learn functions Quiz 2: Learn Argument Labels I Quiz 3: Learn Argument Labels II Quiz 4: Learn default Parameter Values Quiz 5: Learn variadic Parameters Quiz 6: Learn In-Out Parameters Intermediate Module 5: Optionals Quiz 1: Learn Bindings Quiz 2: Learn Chaining Quiz 3: Learn Nil-Coalescing Quiz 4: Learn Unconditional Unwrapping Module 6: Collection Types Quiz 1: Learn Arrays Quiz 2: Learn Sets Quiz 3: Learn Dictionaries Module 7: Object oriented programming Quiz 1: Learn Classes Quiz 2: Learn Inheritance Quiz 3: Learn Protocols Quiz 4: Learn Extensions Module 8: Error Handling Quiz 1: Learn Errors Advanced Module 9: Functional Programming Quiz 1: Learn Closures Quiz 2: Learn Capturing Values Quiz 3: Learn Generic Functions Module 10: Advanced Swift-Lectures Quiz 1: Learn Property Observers Quiz 2: Learn Type Casting Level Beginners Module 1: Introduction to Swift Quiz 1: Create a constant Description : Create a constant named pi and set it to the value 3.14159. Print the variable. Starting Code : ... Solution Code : let pi = 3.14159 print(pi) Quiz 2: Learn comments Description : Comment out the following line in Swift: var x = 10 . Starting Code : var x = 10 Solution Code : // var x = 10 Module 2: Basic concepts in Swift Quiz 1: Declare a variable Description : 1) Declare a variable name of type String and assign it the value \"John\" 2) Create a constant age of Int and set it to 18. 3) Use String Interpolation to print the following text: \"Hello, my name is John and I am 18 years old\" Starting Code : ... Solution Code : var name: String = \"John\" let age: Int = 18 print(\"Hello, my name is \\\\(name) and I am \\\\(age) years old\") Quiz 2: Learn Operators Description : 1) Create two constants a and b of type Int with the values 10 and 18. 2) Add these two variables and store the result in a new constant sum of type Int . 3) Then create a new constant of type Int with the name moduleOperation and perform sum module 10 . Print the result. Starting Code : ... Solution Code : let a: Int = 10 let b: Int = 18 let sum: Int = a + b let moduleOperation: Int = sum % 10 print(moduleOperation) Level Intermediate Module 3: Control Flows Quiz 1: Learn if-else Description : Write an if-else condition that checks if a number number is greater than 10 and prints \"Greater than 10\" or \"Less than or equal to 10\" accordingly. Starting Code : let number = 12 Solution Code : let number = 12 if number > 10 { print(\"Greater than 10\") } else { print(\"Less than or equal to 10\") } Quiz 2: Learn switch Description : Write a switch statement that checks the value of a variable grade and prints \"Excellent\" for A, \"Good\" for B, \"Fair\" for C, \"Poor\" for D, \"Fail\" for F and for default \"Invalid grade\". Starting Code : let grade = \"B\" Solution Code : let grade = \"B\" switch grade { case \"A\": print(\"Excellent\") case \"B\": print(\"Good\") case \"C\": print(\"Fair\") case \"D\": print(\"Poor\") case \"F\": print(\"Fail\") default: print(\"Invalid grade\") } Quiz 3: Learn for-loops Description : Write a for-in loop that iterates over an array of numbers and prints each number. Starting Code : let numbers = [1, 2, 3, 4, 5] Solution Code : let numbers = [1, 2, 3, 4, 5] for number in numbers { print(number) } Quiz 4: Learn while-loops Description : Write a while loop that counts down from 5 to 1 and prints each number (use the -= operator). Starting Code : var counter = 5 Solution Code : var counter = 5 while counter > 0 { print(counter) counter -= 1 } Quiz 5: Learn repeat-while-loops Description : Write a repeat-while loop that counts up from 1 to 5 and prints each number (use the += operator). Starting Code : var count = 1 Solution Code : var count = 1 repeat { print(count) count += 1 } while count <= 5 Quiz 6: Learn continue Description : Write a for-in loop that iterates over the numbers from 1 to 10 and only prints the even numbers. Starting Code : for number in 1...10 { ... } Solution Code : for number in 1...10 { if number % 2 == 0 { print(number) } continue } Quiz 7: Learn break Description : Write a for-in loop that iterates over the numbers from 1 to 10 and breaks the loop when it reaches an even number. Starting Code : for i in 1...10 { ... } Solution Code : for i in 1...10 { if i % 2 == 0 { break } print(i) } Quiz 8: Learn fallthrough Description : Write a switch statement with a case 1 that falls through to the code in case 2 . Starting Code : let value = 1 Solution Code : let value = 1 switch value { case 1: print(\"Case 1\") fallthrough case 2: print(\"Case 2\") default: print(\"Other case\") } Module 4: Functions Quiz 1: Learn functions Description : Write a function square that takes an Int parameter number and prints the result. Starting Code : square(number: 10) Solution Code : func square(number: Int) { print(number * number) } square(number: 10) Quiz 2: Learn Argument Labels I Description : Write a function multiply that takes two parameters a and b and returns their product. Use argument labels number1 and number2 . Starting Code : let result = multiply(number1: 5, number2: 5) print(result) Solution Code : func multiply(number1 a: Int, number2 b: Int) -> Int { return a * b } let result = multiply(number1: 5, number2: 5) print(result) Quiz 3: Learn Argument Labels II Description : Write a function subtract that takes two parameters ( a and b ) without argument labels and returns the difference. Starting Code : let result = subtract(20, 5) print(result) Solution Code : func subtract(_ a: Int, _ b: Int) -> Int { return a - b } let result = subtract(20, 5) print(result) Quiz 4: Learn default Parameter Values Description : Write a function increment that has a parameter number and an optional parameter by (use argument label incrementValue ), which defaults to 1. The function should increment number by the value of by and return the result. Starting Code : let result = increment(5) print(result) Solution Code : func increment(_ number: Int, incrementValue: Int = 1) -> Int { return number + incrementValue } let result = increment(5) print(result) Quiz 5: Learn variadic Parameters Description : Write a function sum that accepts a variable number of Int values and returns their sum . Starting Code : let result = sum(1, 2, 3, 4, 5) print(result) Solution Code : func sum(_ numbers: Int...) -> Int { return numbers.reduce(0, +) } let result = sum(1, 2, 3, 4, 5) print(result) Quiz 6: Learn In-Out Parameters Description : Rewrite the function increment to accept a new parameter result , which saves the result in this variable ( result should be the last parameter). The function should return nothing. Starting Code : func increment(_ number: Int, by incrementValue: Int = 1) -> Int { return number + incrementValue } var result = 0 increment(5, &result) print(result) Solution Code : func increment(_ number: Int, incrementValue: Int = 1, result: inout Int) { result = number + incrementValue } var result = 0 increment(5, result: &result) print(result) Module 5: Optionals Quiz 1: Learn Bindings Description : 1) Write a function printName that accepts an optional string name . 2) Use if let to bind the unwrapped name in a variable called unwrappedName . 3) Print the unwrappedName . 4) Otherwise print \"Name is nil\". Starting Code : printName(\"Alice\") printName(nil) Solution Code : func printName(_ name: String?) { if let unwrappedName = name { print(unwrappedName) } else { print(\"Name is nil\") } } printName(\"Alice\") printName(nil) Quiz 2: Learn Chaining Description : 1) Write a function getUppercaseName that accepts an optional string name and returns the uppercase version of the name. 2) Use optional chaining to access the String function uppercased() . Starting Code : ... let uppercasedName = getUppercaseName(\"Bob\") if let unwrappedUppercasedName = uppercasedName { print(unwrappedUppercasedName) } Solution Code : func getUppercaseName(_ name: String?) -> String? { return name?.uppercased() } let uppercasedName = getUppercaseName(\"Bob\") if let unwrappedUppercasedName = uppercasedName { print(unwrappedUppercasedName) } Quiz 3: Learn Nil-Coalescing Description : Write a function getNameOrDefault that accepts an optional string name and returns the name if it has a value or \"Unknown\" if it is nil. Starting Code : ... let name = getNameOrDefault(nil) print(name) Solution Code : func getNameOrDefault(_ name: String?) -> String { return name ?? \"Unknown\" } let name = getNameOrDefault(nil) print(name) Quiz 4: Learn Unconditional Unwrapping Description : Write a function forceUnwrapName that accepts an optional string name and forcefully unwraps and returns the name. Starting Code : ... let name = forceUnwrapName(\"Charlie\") print(name) Solution Code : func forceUnwrapName(_ name: String?) -> String { return name! } let name = forceUnwrapName(\"Charlie\") print(name) Module 6: Collection Types Quiz 1: Learn Arrays Description : 1) Create an array fruits with the values \"Apple\", \"Banana\", and \"Cherry\". 2) Add \"Orange\" to the fruits array. 3) Remove \"Cherry\" from the fruits array. 4) Change \"Apple\" to \"Mango\". 5) Iterate over the fruits array and print each element. Starting Code : ... Solution Code : var fruits = [\"Apple\", \"Banana\", \"Cherry\"] fruits.append(\"Orange\") fruits.remove(at: 2) fruits[0] = \"Mango\" for fruit in fruits { print(fruit) } Quiz 2: Learn Sets Description : 1) Create a set colors with the values \"Red\", \"Green\", and \"Blue\". 2) Add \"Yellow\" to the colors set. 3) Remove \"Red\" from the colors set. 4) Iterate over the colors set and print each element. 5) Create a new set colors2 with the values \"Yellow\", \"Black\", and \"Magenta\" and combine it with colors to a new set combinedColors . 6) Iterate over the combinedColors set and print each element. Starting Code : ... Solution Code : var colors: Set = [\"Red\", \"Green\", \"Blue\"] colors.insert(\"Yellow\") colors.remove(\"Red\") for color in colors { print(color) } var colors2: Set = [\"Yellow\", \"Black\", \"Magenta\"] var combinedColors = colors.union(colors2) for color in combinedColors { print(color) } Quiz 3: Learn Dictionaries Description : 1) Create a dictionary person with the keys \"name\", \"age\", and \"city\" and the corresponding values \"Alice\", 30, and \"New York\". 2) Change the value of the key \"city\" in the person dictionary to \"Los Angeles\". 3) Remove the value of the key \"name\" in the person dictionary. 4) Iterate over the person dictionary and print each key and value. Starting Code : ... Solution Code : var person: [String: Any] = [\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"] person[\"city\"] = \"Los Angeles\" person[\"name\"] = nil for (key, value) in person { print(\"\\\\(key): \\\\(value)\") } Module 7: Object oriented programming Quiz 1: Learn Classes Description : 1) Define a class Person with the properties name and age . 2) Define a function printInformations() , that prints the following text: \"Hello, my name is name and I am age \" 3) Create an instance of the Person class with the name \"John\" and age 18 and call the function printInformations() . Starting Code : ... Solution Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } let person = Person(name: \"John\", age: 18) person.printInformations() Quiz 2: Learn Inheritance Description : 1) Create a subclass Student that inherits from the Person class and has an additional property grade . 2) Create an instance of the Student class with the name \"John\", age 18 and grade \"A\". Tip: You need to call the function super.init(name:, age:) in the initializer to call the superclass. Starting Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } ... let student = Student(name: \"John\", age: 18, grade: \"A\") student.printInformations() Solution Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } class Student: Person { var grade: String init(name: String, age: Int, grade: String) { self.grade = grade super.init(name: name, age: age) } } let student = Student(name: \"John\", age: 18, grade: \"A\") student.printInformations() Quiz 3: Learn Protocols Description : 1) Define a protocol Vehicle with a method drive . 2) Create a class Car that adopts the Vehicle protocol and implements the drive method. 3) The method drive should print \"Driving a car\". 4) Create an instance of the Car class call the function drive() . Starting Code : ... Solution Code : protocol Vehicle { func drive() } class Car: Vehicle { func drive() { print(\"Driving a car\") } } let car = Car() car.drive() Quiz 4: Learn Extensions Description : 1) Create an extension for the String class that adds a method reversedString which returns the reversed string. 2) Call the method reversedString with the String \"hello\" and print the result. Tip: Use the String method reversed() . Starting Code : ... Solution Code : extension String { func reversedString() -> String { return String(self.reversed()) } } print(\"hello\".reversedString()) Module 8: Error Handling Quiz 1: Learn Errors Description : 1) Define a LoginError enumeration that adopts the Error protocol and has the cases invalidUsername and invalidPassword . 2) Write a function login that checks a username and password and throws an error if the inputs are invalid. 2.1) If username is not \"admin\" throw an error. 2.2) If password is not \"1234\" throw an error. 2.3) Print \"Login successful\" after both checks. 3) Improve the code below with do-catch . Starting Code : ... try login(username: \"admin\", password: \"1234\") print(\"Invalid username\") print(\"Invalid password\") print(\"Other error\") Solution Code : enum LoginError: Error { case invalidUsername, invalidPassword } func login(username: String, password: String) throws { if username != \"admin\" { throw LoginError.invalidUsername } if password != \"1234\" { throw LoginError.invalidPassword } print(\"Login successful\") } do { try login(username: \"admin\", password: \"1234\") } catch LoginError.invalidUsername { print(\"Invalid username\") } catch LoginError.invalidPassword { print(\"Invalid password\") } catch { print(\"Other error\") } Level Advanced Module 9: Functional Programming Quiz 1: Learn Closures Description : Write a simple closure ( add ) that adds two Int ( a and b ) values and returns the result. Starting Code : let add: ... = let result = add(2, 3) print(result) Solution Code : let add: (Int, Int) -> Int = { (a, b) in return a + b } let result = add(2, 3) print(result) Quiz 2: Learn Capturing Values Description : Write a closure that captures an Int variable and increments its value. Starting Code : var counter = 0 ... incrementCounter() print(counter) Solution Code : var counter = 0 let incrementCounter = { counter += 1 } incrementCounter() print(counter) Quiz 3: Learn Generic Functions Description : Write a generic function square that calculates and returns the square of a number. Tip: T must conform to the Numeric protocol. Starting Code : ... var double = square(2.5) var integer = square(10) print(double) print(integer) Solution Code : func square<T: Numeric>(_ number: T) -> T { return number * number } var double = square(2.5) var integer = square(10) print(double) print(integer) Module 10: Advanced Swift-Lectures Quiz 1: Learn Property Observers Description : 1) Create a class BankAccount with a property balance of type Double . 2) Use willSet and didSet observers. 2.1) willSet should print \"Balance is about to change to (newValue)\". 2.2) didSet should print \"Deposited (balance - oldValue) units\" if the balance increased, or \"Withdrew (oldValue - balance) units\" if the balance decreased . 3) Create an instance account and change the balance to 100.0 and to 75.0. Starting Code : ... Solution Code : class BankAccount { var balance: Double = 0.0 { willSet { print(\"Balance is about to change to \\\\(newValue)\") } didSet { if balance > oldValue { print(\"Deposited \\\\(balance - oldValue) units\") } else { print(\"Withdrew \\\\(oldValue - balance) units\") } } } } let account = BankAccount() account.balance = 100.0 account.balance = 75.0 Quiz 2: Learn Type Casting Description : Write a function describeVehicles that accepts an array of Vehicle objects and prints \"Driving a car\" for each Car object and \"Riding a bike\" for each Bike object. Starting Code : class Vehicle {} class Car: Vehicle { func drive() { print(\"Driving a car\") } } class Bike: Vehicle { func ride() { print(\"Riding a bike\") } } let vehicles: [Vehicle] = [Car(), Bike(), Car()] ... describeVehicles(vehicles: vehicles) Solution Code : class Vehicle {} class Car: Vehicle { func drive() { print(\"Driving a car\") } } class Bike: Vehicle { func ride() { print(\"Riding a bike\") } } let vehicles: [Vehicle] = [Car(), Bike(), Car()] func describeVehicles(vehicles: [Vehicle]) { for vehicle in vehicles { if let car = vehicle as? Car { car.drive() } else if let bike = vehicle as? Bike { bike.ride() } } } describeVehicles(vehicles: vehicles) Learn SwiftUI ... ``` Diese Markdown-Datei enth\u00e4lt die Quizzes im gleichen Layout wie zuvor. Wenn du noch weitere Inhalte oder \u00c4nderungen hinzuf\u00fcgen m\u00f6chtest, lass es mich wissen!","title":"Swift-Quizzes"},{"location":"swiftQuiz/#quizzes-for-swift","text":"","title":"Quizzes for Swift"},{"location":"swiftQuiz/#table-of-contents","text":"Beginner Module 1: Introduction to Swift Quiz 1: Create a constant Quiz 2: Learn comments Module 2: Basic concepts in Swift Quiz 1: Declare a variable Quiz 2: Learn Operators Module 3: Control Flows Quiz 1: Learn if-else Quiz 2: Learn switch Quiz 3: Learn for-loops Quiz 4: Learn while-loops Quiz 5: Learn repeat-while-loops Quiz 6: Learn continue Quiz 7: Learn break Quiz 8: Learn fallthrough Module 4: Functions Quiz 1: Learn functions Quiz 2: Learn Argument Labels I Quiz 3: Learn Argument Labels II Quiz 4: Learn default Parameter Values Quiz 5: Learn variadic Parameters Quiz 6: Learn In-Out Parameters Intermediate Module 5: Optionals Quiz 1: Learn Bindings Quiz 2: Learn Chaining Quiz 3: Learn Nil-Coalescing Quiz 4: Learn Unconditional Unwrapping Module 6: Collection Types Quiz 1: Learn Arrays Quiz 2: Learn Sets Quiz 3: Learn Dictionaries Module 7: Object oriented programming Quiz 1: Learn Classes Quiz 2: Learn Inheritance Quiz 3: Learn Protocols Quiz 4: Learn Extensions Module 8: Error Handling Quiz 1: Learn Errors Advanced Module 9: Functional Programming Quiz 1: Learn Closures Quiz 2: Learn Capturing Values Quiz 3: Learn Generic Functions Module 10: Advanced Swift-Lectures Quiz 1: Learn Property Observers Quiz 2: Learn Type Casting","title":"Table of contents"},{"location":"swiftQuiz/#level-beginners","text":"","title":"Level Beginners"},{"location":"swiftQuiz/#module-1-introduction-to-swift","text":"","title":"Module 1: Introduction to Swift"},{"location":"swiftQuiz/#quiz-1-create-a-constant","text":"Description : Create a constant named pi and set it to the value 3.14159. Print the variable. Starting Code : ... Solution Code : let pi = 3.14159 print(pi)","title":"Quiz 1: Create a constant"},{"location":"swiftQuiz/#quiz-2-learn-comments","text":"Description : Comment out the following line in Swift: var x = 10 . Starting Code : var x = 10 Solution Code : // var x = 10","title":"Quiz 2: Learn comments"},{"location":"swiftQuiz/#module-2-basic-concepts-in-swift","text":"","title":"Module 2: Basic concepts in Swift"},{"location":"swiftQuiz/#quiz-1-declare-a-variable","text":"Description : 1) Declare a variable name of type String and assign it the value \"John\" 2) Create a constant age of Int and set it to 18. 3) Use String Interpolation to print the following text: \"Hello, my name is John and I am 18 years old\" Starting Code : ... Solution Code : var name: String = \"John\" let age: Int = 18 print(\"Hello, my name is \\\\(name) and I am \\\\(age) years old\")","title":"Quiz 1: Declare a variable"},{"location":"swiftQuiz/#quiz-2-learn-operators","text":"Description : 1) Create two constants a and b of type Int with the values 10 and 18. 2) Add these two variables and store the result in a new constant sum of type Int . 3) Then create a new constant of type Int with the name moduleOperation and perform sum module 10 . Print the result. Starting Code : ... Solution Code : let a: Int = 10 let b: Int = 18 let sum: Int = a + b let moduleOperation: Int = sum % 10 print(moduleOperation)","title":"Quiz 2: Learn Operators"},{"location":"swiftQuiz/#level-intermediate","text":"","title":"Level Intermediate"},{"location":"swiftQuiz/#module-3-control-flows","text":"","title":"Module 3: Control Flows"},{"location":"swiftQuiz/#quiz-1-learn-if-else","text":"Description : Write an if-else condition that checks if a number number is greater than 10 and prints \"Greater than 10\" or \"Less than or equal to 10\" accordingly. Starting Code : let number = 12 Solution Code : let number = 12 if number > 10 { print(\"Greater than 10\") } else { print(\"Less than or equal to 10\") }","title":"Quiz 1: Learn if-else"},{"location":"swiftQuiz/#quiz-2-learn-switch","text":"Description : Write a switch statement that checks the value of a variable grade and prints \"Excellent\" for A, \"Good\" for B, \"Fair\" for C, \"Poor\" for D, \"Fail\" for F and for default \"Invalid grade\". Starting Code : let grade = \"B\" Solution Code : let grade = \"B\" switch grade { case \"A\": print(\"Excellent\") case \"B\": print(\"Good\") case \"C\": print(\"Fair\") case \"D\": print(\"Poor\") case \"F\": print(\"Fail\") default: print(\"Invalid grade\") }","title":"Quiz 2: Learn switch"},{"location":"swiftQuiz/#quiz-3-learn-for-loops","text":"Description : Write a for-in loop that iterates over an array of numbers and prints each number. Starting Code : let numbers = [1, 2, 3, 4, 5] Solution Code : let numbers = [1, 2, 3, 4, 5] for number in numbers { print(number) }","title":"Quiz 3: Learn for-loops"},{"location":"swiftQuiz/#quiz-4-learn-while-loops","text":"Description : Write a while loop that counts down from 5 to 1 and prints each number (use the -= operator). Starting Code : var counter = 5 Solution Code : var counter = 5 while counter > 0 { print(counter) counter -= 1 }","title":"Quiz 4: Learn while-loops"},{"location":"swiftQuiz/#quiz-5-learn-repeat-while-loops","text":"Description : Write a repeat-while loop that counts up from 1 to 5 and prints each number (use the += operator). Starting Code : var count = 1 Solution Code : var count = 1 repeat { print(count) count += 1 } while count <= 5","title":"Quiz 5: Learn repeat-while-loops"},{"location":"swiftQuiz/#quiz-6-learn-continue","text":"Description : Write a for-in loop that iterates over the numbers from 1 to 10 and only prints the even numbers. Starting Code : for number in 1...10 { ... } Solution Code : for number in 1...10 { if number % 2 == 0 { print(number) } continue }","title":"Quiz 6: Learn continue"},{"location":"swiftQuiz/#quiz-7-learn-break","text":"Description : Write a for-in loop that iterates over the numbers from 1 to 10 and breaks the loop when it reaches an even number. Starting Code : for i in 1...10 { ... } Solution Code : for i in 1...10 { if i % 2 == 0 { break } print(i) }","title":"Quiz 7: Learn break"},{"location":"swiftQuiz/#quiz-8-learn-fallthrough","text":"Description : Write a switch statement with a case 1 that falls through to the code in case 2 . Starting Code : let value = 1 Solution Code : let value = 1 switch value { case 1: print(\"Case 1\") fallthrough case 2: print(\"Case 2\") default: print(\"Other case\") }","title":"Quiz 8: Learn fallthrough"},{"location":"swiftQuiz/#module-4-functions","text":"","title":"Module 4: Functions"},{"location":"swiftQuiz/#quiz-1-learn-functions","text":"Description : Write a function square that takes an Int parameter number and prints the result. Starting Code : square(number: 10) Solution Code : func square(number: Int) { print(number * number) } square(number: 10)","title":"Quiz 1: Learn functions"},{"location":"swiftQuiz/#quiz-2-learn-argument-labels-i","text":"Description : Write a function multiply that takes two parameters a and b and returns their product. Use argument labels number1 and number2 . Starting Code : let result = multiply(number1: 5, number2: 5) print(result) Solution Code : func multiply(number1 a: Int, number2 b: Int) -> Int { return a * b } let result = multiply(number1: 5, number2: 5) print(result)","title":"Quiz 2: Learn Argument Labels I"},{"location":"swiftQuiz/#quiz-3-learn-argument-labels-ii","text":"Description : Write a function subtract that takes two parameters ( a and b ) without argument labels and returns the difference. Starting Code : let result = subtract(20, 5) print(result) Solution Code : func subtract(_ a: Int, _ b: Int) -> Int { return a - b } let result = subtract(20, 5) print(result)","title":"Quiz 3: Learn Argument Labels II"},{"location":"swiftQuiz/#quiz-4-learn-default-parameter-values","text":"Description : Write a function increment that has a parameter number and an optional parameter by (use argument label incrementValue ), which defaults to 1. The function should increment number by the value of by and return the result. Starting Code : let result = increment(5) print(result) Solution Code : func increment(_ number: Int, incrementValue: Int = 1) -> Int { return number + incrementValue } let result = increment(5) print(result)","title":"Quiz 4: Learn default Parameter Values"},{"location":"swiftQuiz/#quiz-5-learn-variadic-parameters","text":"Description : Write a function sum that accepts a variable number of Int values and returns their sum . Starting Code : let result = sum(1, 2, 3, 4, 5) print(result) Solution Code : func sum(_ numbers: Int...) -> Int { return numbers.reduce(0, +) } let result = sum(1, 2, 3, 4, 5) print(result)","title":"Quiz 5: Learn variadic Parameters"},{"location":"swiftQuiz/#quiz-6-learn-in-out-parameters","text":"Description : Rewrite the function increment to accept a new parameter result , which saves the result in this variable ( result should be the last parameter). The function should return nothing. Starting Code : func increment(_ number: Int, by incrementValue: Int = 1) -> Int { return number + incrementValue } var result = 0 increment(5, &result) print(result) Solution Code : func increment(_ number: Int, incrementValue: Int = 1, result: inout Int) { result = number + incrementValue } var result = 0 increment(5, result: &result) print(result)","title":"Quiz 6: Learn In-Out Parameters"},{"location":"swiftQuiz/#module-5-optionals","text":"","title":"Module 5: Optionals"},{"location":"swiftQuiz/#quiz-1-learn-bindings","text":"Description : 1) Write a function printName that accepts an optional string name . 2) Use if let to bind the unwrapped name in a variable called unwrappedName . 3) Print the unwrappedName . 4) Otherwise print \"Name is nil\". Starting Code : printName(\"Alice\") printName(nil) Solution Code : func printName(_ name: String?) { if let unwrappedName = name { print(unwrappedName) } else { print(\"Name is nil\") } } printName(\"Alice\") printName(nil)","title":"Quiz 1: Learn Bindings"},{"location":"swiftQuiz/#quiz-2-learn-chaining","text":"Description : 1) Write a function getUppercaseName that accepts an optional string name and returns the uppercase version of the name. 2) Use optional chaining to access the String function uppercased() . Starting Code : ... let uppercasedName = getUppercaseName(\"Bob\") if let unwrappedUppercasedName = uppercasedName { print(unwrappedUppercasedName) } Solution Code : func getUppercaseName(_ name: String?) -> String? { return name?.uppercased() } let uppercasedName = getUppercaseName(\"Bob\") if let unwrappedUppercasedName = uppercasedName { print(unwrappedUppercasedName) }","title":"Quiz 2: Learn Chaining"},{"location":"swiftQuiz/#quiz-3-learn-nil-coalescing","text":"Description : Write a function getNameOrDefault that accepts an optional string name and returns the name if it has a value or \"Unknown\" if it is nil. Starting Code : ... let name = getNameOrDefault(nil) print(name) Solution Code : func getNameOrDefault(_ name: String?) -> String { return name ?? \"Unknown\" } let name = getNameOrDefault(nil) print(name)","title":"Quiz 3: Learn Nil-Coalescing"},{"location":"swiftQuiz/#quiz-4-learn-unconditional-unwrapping","text":"Description : Write a function forceUnwrapName that accepts an optional string name and forcefully unwraps and returns the name. Starting Code : ... let name = forceUnwrapName(\"Charlie\") print(name) Solution Code : func forceUnwrapName(_ name: String?) -> String { return name! } let name = forceUnwrapName(\"Charlie\") print(name)","title":"Quiz 4: Learn Unconditional Unwrapping"},{"location":"swiftQuiz/#module-6-collection-types","text":"","title":"Module 6: Collection Types"},{"location":"swiftQuiz/#quiz-1-learn-arrays","text":"Description : 1) Create an array fruits with the values \"Apple\", \"Banana\", and \"Cherry\". 2) Add \"Orange\" to the fruits array. 3) Remove \"Cherry\" from the fruits array. 4) Change \"Apple\" to \"Mango\". 5) Iterate over the fruits array and print each element. Starting Code : ... Solution Code : var fruits = [\"Apple\", \"Banana\", \"Cherry\"] fruits.append(\"Orange\") fruits.remove(at: 2) fruits[0] = \"Mango\" for fruit in fruits { print(fruit) }","title":"Quiz 1: Learn Arrays"},{"location":"swiftQuiz/#quiz-2-learn-sets","text":"Description : 1) Create a set colors with the values \"Red\", \"Green\", and \"Blue\". 2) Add \"Yellow\" to the colors set. 3) Remove \"Red\" from the colors set. 4) Iterate over the colors set and print each element. 5) Create a new set colors2 with the values \"Yellow\", \"Black\", and \"Magenta\" and combine it with colors to a new set combinedColors . 6) Iterate over the combinedColors set and print each element. Starting Code : ... Solution Code : var colors: Set = [\"Red\", \"Green\", \"Blue\"] colors.insert(\"Yellow\") colors.remove(\"Red\") for color in colors { print(color) } var colors2: Set = [\"Yellow\", \"Black\", \"Magenta\"] var combinedColors = colors.union(colors2) for color in combinedColors { print(color) }","title":"Quiz 2: Learn Sets"},{"location":"swiftQuiz/#quiz-3-learn-dictionaries","text":"Description : 1) Create a dictionary person with the keys \"name\", \"age\", and \"city\" and the corresponding values \"Alice\", 30, and \"New York\". 2) Change the value of the key \"city\" in the person dictionary to \"Los Angeles\". 3) Remove the value of the key \"name\" in the person dictionary. 4) Iterate over the person dictionary and print each key and value. Starting Code : ... Solution Code : var person: [String: Any] = [\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"] person[\"city\"] = \"Los Angeles\" person[\"name\"] = nil for (key, value) in person { print(\"\\\\(key): \\\\(value)\") }","title":"Quiz 3: Learn Dictionaries"},{"location":"swiftQuiz/#module-7-object-oriented-programming","text":"","title":"Module 7: Object oriented programming"},{"location":"swiftQuiz/#quiz-1-learn-classes","text":"Description : 1) Define a class Person with the properties name and age . 2) Define a function printInformations() , that prints the following text: \"Hello, my name is name and I am age \" 3) Create an instance of the Person class with the name \"John\" and age 18 and call the function printInformations() . Starting Code : ... Solution Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } let person = Person(name: \"John\", age: 18) person.printInformations()","title":"Quiz 1: Learn Classes"},{"location":"swiftQuiz/#quiz-2-learn-inheritance","text":"Description : 1) Create a subclass Student that inherits from the Person class and has an additional property grade . 2) Create an instance of the Student class with the name \"John\", age 18 and grade \"A\". Tip: You need to call the function super.init(name:, age:) in the initializer to call the superclass. Starting Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } ... let student = Student(name: \"John\", age: 18, grade: \"A\") student.printInformations() Solution Code : class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } func printInformations() { print(\"Hello, my name is \\\\(name) and I am \\\\(age)\") } } class Student: Person { var grade: String init(name: String, age: Int, grade: String) { self.grade = grade super.init(name: name, age: age) } } let student = Student(name: \"John\", age: 18, grade: \"A\") student.printInformations()","title":"Quiz 2: Learn Inheritance"},{"location":"swiftQuiz/#quiz-3-learn-protocols","text":"Description : 1) Define a protocol Vehicle with a method drive . 2) Create a class Car that adopts the Vehicle protocol and implements the drive method. 3) The method drive should print \"Driving a car\". 4) Create an instance of the Car class call the function drive() . Starting Code : ... Solution Code : protocol Vehicle { func drive() } class Car: Vehicle { func drive() { print(\"Driving a car\") } } let car = Car() car.drive()","title":"Quiz 3: Learn Protocols"},{"location":"swiftQuiz/#quiz-4-learn-extensions","text":"Description : 1) Create an extension for the String class that adds a method reversedString which returns the reversed string. 2) Call the method reversedString with the String \"hello\" and print the result. Tip: Use the String method reversed() . Starting Code : ... Solution Code : extension String { func reversedString() -> String { return String(self.reversed()) } } print(\"hello\".reversedString())","title":"Quiz 4: Learn Extensions"},{"location":"swiftQuiz/#module-8-error-handling","text":"","title":"Module 8: Error Handling"},{"location":"swiftQuiz/#quiz-1-learn-errors","text":"Description : 1) Define a LoginError enumeration that adopts the Error protocol and has the cases invalidUsername and invalidPassword . 2) Write a function login that checks a username and password and throws an error if the inputs are invalid. 2.1) If username is not \"admin\" throw an error. 2.2) If password is not \"1234\" throw an error. 2.3) Print \"Login successful\" after both checks. 3) Improve the code below with do-catch . Starting Code : ... try login(username: \"admin\", password: \"1234\") print(\"Invalid username\") print(\"Invalid password\") print(\"Other error\") Solution Code : enum LoginError: Error { case invalidUsername, invalidPassword } func login(username: String, password: String) throws { if username != \"admin\" { throw LoginError.invalidUsername } if password != \"1234\" { throw LoginError.invalidPassword } print(\"Login successful\") } do { try login(username: \"admin\", password: \"1234\") } catch LoginError.invalidUsername { print(\"Invalid username\") } catch LoginError.invalidPassword { print(\"Invalid password\") } catch { print(\"Other error\") }","title":"Quiz 1: Learn Errors"},{"location":"swiftQuiz/#level-advanced","text":"","title":"Level Advanced"},{"location":"swiftQuiz/#module-9-functional-programming","text":"","title":"Module 9: Functional Programming"},{"location":"swiftQuiz/#quiz-1-learn-closures","text":"Description : Write a simple closure ( add ) that adds two Int ( a and b ) values and returns the result. Starting Code : let add: ... = let result = add(2, 3) print(result) Solution Code : let add: (Int, Int) -> Int = { (a, b) in return a + b } let result = add(2, 3) print(result)","title":"Quiz 1: Learn Closures"},{"location":"swiftQuiz/#quiz-2-learn-capturing-values","text":"Description : Write a closure that captures an Int variable and increments its value. Starting Code : var counter = 0 ... incrementCounter() print(counter) Solution Code : var counter = 0 let incrementCounter = { counter += 1 } incrementCounter() print(counter)","title":"Quiz 2: Learn Capturing Values"},{"location":"swiftQuiz/#quiz-3-learn-generic-functions","text":"Description : Write a generic function square that calculates and returns the square of a number. Tip: T must conform to the Numeric protocol. Starting Code : ... var double = square(2.5) var integer = square(10) print(double) print(integer) Solution Code : func square<T: Numeric>(_ number: T) -> T { return number * number } var double = square(2.5) var integer = square(10) print(double) print(integer)","title":"Quiz 3: Learn Generic Functions"},{"location":"swiftQuiz/#module-10-advanced-swift-lectures","text":"","title":"Module 10: Advanced Swift-Lectures"},{"location":"swiftQuiz/#quiz-1-learn-property-observers","text":"Description : 1) Create a class BankAccount with a property balance of type Double . 2) Use willSet and didSet observers. 2.1) willSet should print \"Balance is about to change to (newValue)\". 2.2) didSet should print \"Deposited (balance - oldValue) units\" if the balance increased, or \"Withdrew (oldValue - balance) units\" if the balance decreased . 3) Create an instance account and change the balance to 100.0 and to 75.0. Starting Code : ... Solution Code : class BankAccount { var balance: Double = 0.0 { willSet { print(\"Balance is about to change to \\\\(newValue)\") } didSet { if balance > oldValue { print(\"Deposited \\\\(balance - oldValue) units\") } else { print(\"Withdrew \\\\(oldValue - balance) units\") } } } } let account = BankAccount() account.balance = 100.0 account.balance = 75.0","title":"Quiz 1: Learn Property Observers"},{"location":"swiftQuiz/#quiz-2-learn-type-casting","text":"Description : Write a function describeVehicles that accepts an array of Vehicle objects and prints \"Driving a car\" for each Car object and \"Riding a bike\" for each Bike object. Starting Code : class Vehicle {} class Car: Vehicle { func drive() { print(\"Driving a car\") } } class Bike: Vehicle { func ride() { print(\"Riding a bike\") } } let vehicles: [Vehicle] = [Car(), Bike(), Car()] ... describeVehicles(vehicles: vehicles) Solution Code : class Vehicle {} class Car: Vehicle { func drive() { print(\"Driving a car\") } } class Bike: Vehicle { func ride() { print(\"Riding a bike\") } } let vehicles: [Vehicle] = [Car(), Bike(), Car()] func describeVehicles(vehicles: [Vehicle]) { for vehicle in vehicles { if let car = vehicle as? Car { car.drive() } else if let bike = vehicle as? Bike { bike.ride() } } } describeVehicles(vehicles: vehicles)","title":"Quiz 2: Learn Type Casting"},{"location":"swiftQuiz/#learn-swiftui","text":"... ``` Diese Markdown-Datei enth\u00e4lt die Quizzes im gleichen Layout wie zuvor. Wenn du noch weitere Inhalte oder \u00c4nderungen hinzuf\u00fcgen m\u00f6chtest, lass es mich wissen!","title":"Learn SwiftUI"},{"location":"swiftUI/","text":"Learn SwiftUI Table of contents Beginner Module 11: Introduction to SwiftUI Introduction Declarative Syntax Module 12: State Management in SwiftUI State Binding StateObject ObservedObject EnvironmentObject Intermediate Module 13: Components in SwiftUI Button Part I Button Part II Button Part III TextField Slider Toggle System Images Module 14: Navigation and Views Navigation TabView Advanced Module 15: Advanced SwiftUI-Lectures Rotation Effect Scale Effects Level Beginner Module 11: Introduction to SwiftUI Introduction SwiftUI helps you build great-looking apps across all Apple platforms with the power of Swift \u2014 and surprisingly little code. You can bring even better experiences to everyone, on any Apple device, using just one set of tools and APIs. SwiftUI Documentation Declarative Syntax SwiftUI uses a declarative syntax, so you can simply state what your user interface should do. For example, you can write that you want a list of items consisting of text fields, then describe alignment, font, and color for each field. Your code is simpler and easier to read than ever before, saving you time and maintenance. The following example displays a Text of \"Hello World\" with a font size of 32 and color red: struct TextView: View { var body: some View { Text(\"Hello World\") .font(.system(size: 32)) .foregroundColor(.red) } } SwiftUI Documentation Module 12: State Management in SwiftUI State A property wrapper type that can read and write a value managed by SwiftUI. Use state as the single source of truth for a given value type that you store in a view hierarchy. Create a state value in a View by applying the @State attribute to a property declaration and providing an initial value. Declare state as private to prevent setting it in a memberwise initializer, which can conflict with the storage management that SwiftUI provides: struct PlayButton: View { @State private var isPlaying: Bool = false // Create the state. var body: some View { Button(isPlaying ? \"Pause\" : \"Play\") { // Read the state. isPlaying.toggle() // Write the state. } } } State Documentation Binding A property wrapper type that can read and write a value owned by a source of truth. Use a binding to create a two-way connection between a property that stores data, and a view that displays and changes the data. A binding connects a property to a source of truth stored elsewhere, instead of storing data directly. For example, a button that toggles between play and pause can create a binding to a property of its parent view using the Binding property wrapper. The parent view declares a property to hold the playing state, using the State property wrapper to indicate that this property is the value\u2019s source of truth: struct PlayButton: View { @Binding private var isPlaying: Bool var body: some View { Button(isPlaying ? \"Pause\" : \"Play\") { isPlaying.toggle() } } } struct PlayerView: View { var episode: Episode @State private var isPlaying: Bool = false var body: some View { VStack { Text(episode.title) .foregroundStyle(isPlaying ? .primary : .secondary) PlayButton(isPlaying: $isPlaying) } } } Binding Documentation StateObject A property wrapper type that instantiates an observable object. Use a state object as the single source of truth for a reference type that you store in a view hierarchy. Create a state object in a View by applying the @StateObject attribute to a property declaration and providing an initial value that conforms to the ObservableObject protocol. Declare state objects as private to prevent setting them from a memberwise initializer, which can conflict with the storage management that SwiftUI provides. In this example, the DataModel class conforms to the ObservableObject protocol and has two published properties: name , a string initialized to \"Some Name,\" and isEnabled , a boolean initialized to false . These properties can be observed for changes in SwiftUI views. class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MySubView: View { var body: some View { Text(\"Subview\") } } struct MyView: View { @StateObject private var model = DataModel() // Create the state object. var body: some View { Text(model.name) // Updates when the data model changes. MySubView() .environmentObject(model) } } StateObject Documentation ObservedObject A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes. Add the @ObservedObject attribute to a parameter of a SwiftUI View when the input is an ObservableObject and you want the view to update when the object\u2019s published properties change. You typically do this to pass a StateObject into a subview. The following example defines a data model as an observable object, instantiates the model in a view as a state object, and then passes the instance to a subview as an observed object: class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MyView: View { @StateObject private var model = DataModel() var body: some View { Text(model.name) MySubView(model: model) } } struct MySubView: View { @ObservedObject var model: DataModel var body: some View { Toggle(\"Enabled\", isOn: $model.isEnabled) } } ObservedObject Documentation EnvironmentObject A property wrapper type for an observable object that a parent or ancestor view supplies. An environment object invalidates the current view whenever the observable object that conforms to ObservableObject changes. If you declare a property as an environment object, be sure to set a corresponding model object on an ancestor view by calling its environmentObject(_:) modifier. Here's an example: class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MyView: View { @StateObject private var model = DataModel() var body: some View { Text(model.name) MySubView() .environmentObject(model) } } struct MySubView: View { @EnvironmentObject var model: DataModel var body: some View { Toggle(\"Enabled\", isOn: $model.isEnabled) } } EnvironmentObject Documentation Level Intermediate Module 13: Components in SwiftUI Button Part I You create a button by providing an action and a label. The action is either a method or closure property that does something when a user clicks or taps the button. The label is a view that describes the button\u2019s action \u2014 for example, by showing text, an icon, or both. The label of a button can be any kind of view, such as a Text view for text-only labels or a Label view, for buttons with both a title and an icon: struct ButtonView: View { var body: some View { Button(action: signIn) { Text(\"Sign In\") // Only Title // Label(\"Sign In\", systemImage: \"arrow.up\") // Title and an icon } } func signIn { // do something } } Button Documentation Button Part II You can optionally initialize a button with a ButtonRole that characterizes the button\u2019s purpose. For example, you can create a destructive button for a deletion action: struct ButtonView: View { var body: some View { Button(\"Delete\", role: .destructive, action: delete) } func delete { // do something } } Button Documentation Button Part III You can customize a button\u2019s appearance using one of the standard button styles, like bordered , and apply the style with the buttonStyle(_:) modifier: struct ButtonView: View { var body: some View { Button(\"Sign In\", action: signIn) .buttonStyle(.bordered) } func signIn { // do something } } Button Documentation TextField You create a text field with a label and a binding to a value. If the value is a string, the text field updates this value continuously as the user types or otherwise edits the text in the field. For non-string types, it updates the value when the user commits their edits, such as by pressing the Return key. The following example shows a text field to accept a username, and a Text view below it that shadows the continuously updated value of username. The Text view changes color as the user begins and ends editing. When the user submits their completed entry to the text field, the onSubmit(of:_:) modifer calls an internal validate(name:) method. struct TextFieldView: View { @State private var username: String = \"\" var body: some View { TextField( \"User name (email address)\", text: $username ) .onSubmit { // validate(name: username) } .textInputAutocapitalization(.never) .disableAutocorrection(true) .border(.secondary) Text(username) .foregroundColor(.blue) } } TextField Documentation Slider A control for selecting a value from a bounded linear range of values. A slider consists of a \u201cthumb\u201d image that the user moves between two extremes of a linear \u201ctrack\u201d. The ends of the track represent the minimum and maximum possible values. As the user moves the thumb, the slider updates its bound value. The following example shows a slider bound to the value speed. As the slider updates this value, a bound Text view shows the value updating. The onEditingChanged closure passed to the slider receives callbacks when the user drags the slider. The example uses this to change the color of the value text. struct SliderView: View { @State private var speed = 50.0 @State private var isEditing = false var body: some View { VStack { Slider( value: $speed, in: 0...100, onEditingChanged: { editing in isEditing = editing } ) Text(\"\\(speed)\") .foregroundColor(isEditing ? .red : .blue) } } } Slider Documentation Toggle A control for selecting a value from a bounded linear range of values. You create a toggle by providing an isOn binding and a label. Bind isOn to a Boolean property that determines whether the toggle is on or off. Set the label to a view that visually describes the purpose of switching between toggle states. For example: struct SliderView: View { @State private var vibrateOnRing = false var body: some View { Toggle(isOn: $vibrateOnRing) { Text(\"Vibrate on Ring\") } } } Toggle Documentation System Images Symbol images give you a consistent set of icons to use in your app, and ensure that those icons adapt to different sizes and to app-specific content. A symbol image contains a vector-based shape that scales without losing its sharpness. You generate its final appearance by applying a tint color, or if you\u2019re using SF Symbols 2 or later, you can apply multiple colors to add depth and emphasis to your symbol. You use symbol images in places where you display a simple shape or glyph, such as a bar button item. In SwiftUI, you use Image(systemName:) to load a system symbol image and Image(_:) to load your custom symbol, as the following code shows: struct SystemImagesView: View { var body: some View { // Create a system symbol image. Image(systemName: \"multiply.circle.fill\") } } System Images Documentation Module 14: Navigation and Views Navigation A view that displays a root view and enables you to present additional views over the root view. Use a navigation stack to present a stack of views over a root view. People can add views to the top of the stack by clicking or tapping a NavigationLink , and remove views using built-in, platform-appropriate controls, like a Back button or a swipe gesture. The stack always displays the most recently added view that hasn\u2019t been removed, and doesn\u2019t allow the root view to be removed. To create navigation links, associate a view with a data type by adding a navigationDestination(for:destination:) modifier inside the stack\u2019s view hierarchy. Then initialize a NavigationLink that presents an instance of the same kind of data. This example defines a view with a list of names displayed using a NavigationStack . Each name in the list is a navigation link that, when tapped, navigates to a new view displaying the selected name as text. struct NavigationExampleView: View { var names: [String] = [\"Paul\", \"Abraham\", \"Leon\", \"Elias\", \"Eren\", \"Canel\"] var body: some View { NavigationStack { List(names) { name in NavigationLink(name, value: name) } .navigationDestination(for: String.self) { name in Text(name) } } } } NavigationStack Documentation TabView To create a user interface with tabs, place views in a TabView and apply the tabItem(_:) modifier to the contents of each tab. On iOS, you can also use one of the badge modifiers, like badge(_:) , to assign a badge to each of the tabs. This example defines a view with TabView containing two tabs. The first tab displays \"First Tab\" with a badge of \"2\" and an icon of a circle with the number 1. The second tab displays \"Second Tab\" with a badge of \"!\" and an icon of a circle with the number 2: struct TabViewExample: View { var body: some View { TabView { Text(\"First Tab\") .badge(\"2\") .tabItem { Image(systemName: \"1.circle\") Text(\"First\") } Text(\"Second Tab\") .badge(\"!\") .tabItem { Image(systemName: \"2.circle\") Text(\"Second\") } } } } TabView Documentation Level Advanced Module 15: Advanced SwiftUI-Lectures Rotation Effect Rotates a view\u2019s rendered output in two dimensions around the specified point. This example defines a view that includes a state variable isRotated initialized to false to control the rotation of an arrow image. The view contains an Image that rotates 90 degrees when isRotated is true , with an ease-in-out animation of 1 second. Tapping the image toggles the rotation state: struct BasicAnimationView: View { @State private var isRotated = false var body: some View { Image(systemName: \"arrow.right.circle.fill\") .rotationEffect(.degrees(isRotated ? 90 : 0)) .animation(.easeInOut(duration: 1)) .onTapGesture { isRotated.toggle() } } } RotationEffect Documentation Scale Effects Scales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point. This example defines a view that includes a state variable scale initialized to 1.0 to control the scaling of a star image. The view contains a vertically stacked Image with a scaling effect and animation, and a button that increases the scale by 0.5 when tapped, triggering the animation. struct AnimationView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { Image(systemName: \"star.fill\") .scaleEffect(scale) .animation(.easeInOut(duration: 1)) Button(\"Animate\") { scale += 0.5 } } } } ScaleEffect Documentation","title":"SwiftUI"},{"location":"swiftUI/#learn-swiftui","text":"","title":"Learn SwiftUI"},{"location":"swiftUI/#table-of-contents","text":"Beginner Module 11: Introduction to SwiftUI Introduction Declarative Syntax Module 12: State Management in SwiftUI State Binding StateObject ObservedObject EnvironmentObject Intermediate Module 13: Components in SwiftUI Button Part I Button Part II Button Part III TextField Slider Toggle System Images Module 14: Navigation and Views Navigation TabView Advanced Module 15: Advanced SwiftUI-Lectures Rotation Effect Scale Effects","title":"Table of contents"},{"location":"swiftUI/#level-beginner","text":"","title":"Level Beginner"},{"location":"swiftUI/#module-11-introduction-to-swiftui","text":"","title":"Module 11: Introduction to SwiftUI"},{"location":"swiftUI/#introduction","text":"SwiftUI helps you build great-looking apps across all Apple platforms with the power of Swift \u2014 and surprisingly little code. You can bring even better experiences to everyone, on any Apple device, using just one set of tools and APIs. SwiftUI Documentation","title":"Introduction"},{"location":"swiftUI/#declarative-syntax","text":"SwiftUI uses a declarative syntax, so you can simply state what your user interface should do. For example, you can write that you want a list of items consisting of text fields, then describe alignment, font, and color for each field. Your code is simpler and easier to read than ever before, saving you time and maintenance. The following example displays a Text of \"Hello World\" with a font size of 32 and color red: struct TextView: View { var body: some View { Text(\"Hello World\") .font(.system(size: 32)) .foregroundColor(.red) } } SwiftUI Documentation","title":"Declarative Syntax"},{"location":"swiftUI/#module-12-state-management-in-swiftui","text":"","title":"Module 12: State Management in SwiftUI"},{"location":"swiftUI/#state","text":"A property wrapper type that can read and write a value managed by SwiftUI. Use state as the single source of truth for a given value type that you store in a view hierarchy. Create a state value in a View by applying the @State attribute to a property declaration and providing an initial value. Declare state as private to prevent setting it in a memberwise initializer, which can conflict with the storage management that SwiftUI provides: struct PlayButton: View { @State private var isPlaying: Bool = false // Create the state. var body: some View { Button(isPlaying ? \"Pause\" : \"Play\") { // Read the state. isPlaying.toggle() // Write the state. } } } State Documentation","title":"State"},{"location":"swiftUI/#binding","text":"A property wrapper type that can read and write a value owned by a source of truth. Use a binding to create a two-way connection between a property that stores data, and a view that displays and changes the data. A binding connects a property to a source of truth stored elsewhere, instead of storing data directly. For example, a button that toggles between play and pause can create a binding to a property of its parent view using the Binding property wrapper. The parent view declares a property to hold the playing state, using the State property wrapper to indicate that this property is the value\u2019s source of truth: struct PlayButton: View { @Binding private var isPlaying: Bool var body: some View { Button(isPlaying ? \"Pause\" : \"Play\") { isPlaying.toggle() } } } struct PlayerView: View { var episode: Episode @State private var isPlaying: Bool = false var body: some View { VStack { Text(episode.title) .foregroundStyle(isPlaying ? .primary : .secondary) PlayButton(isPlaying: $isPlaying) } } } Binding Documentation","title":"Binding"},{"location":"swiftUI/#stateobject","text":"A property wrapper type that instantiates an observable object. Use a state object as the single source of truth for a reference type that you store in a view hierarchy. Create a state object in a View by applying the @StateObject attribute to a property declaration and providing an initial value that conforms to the ObservableObject protocol. Declare state objects as private to prevent setting them from a memberwise initializer, which can conflict with the storage management that SwiftUI provides. In this example, the DataModel class conforms to the ObservableObject protocol and has two published properties: name , a string initialized to \"Some Name,\" and isEnabled , a boolean initialized to false . These properties can be observed for changes in SwiftUI views. class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MySubView: View { var body: some View { Text(\"Subview\") } } struct MyView: View { @StateObject private var model = DataModel() // Create the state object. var body: some View { Text(model.name) // Updates when the data model changes. MySubView() .environmentObject(model) } } StateObject Documentation","title":"StateObject"},{"location":"swiftUI/#observedobject","text":"A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes. Add the @ObservedObject attribute to a parameter of a SwiftUI View when the input is an ObservableObject and you want the view to update when the object\u2019s published properties change. You typically do this to pass a StateObject into a subview. The following example defines a data model as an observable object, instantiates the model in a view as a state object, and then passes the instance to a subview as an observed object: class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MyView: View { @StateObject private var model = DataModel() var body: some View { Text(model.name) MySubView(model: model) } } struct MySubView: View { @ObservedObject var model: DataModel var body: some View { Toggle(\"Enabled\", isOn: $model.isEnabled) } } ObservedObject Documentation","title":"ObservedObject"},{"location":"swiftUI/#environmentobject","text":"A property wrapper type for an observable object that a parent or ancestor view supplies. An environment object invalidates the current view whenever the observable object that conforms to ObservableObject changes. If you declare a property as an environment object, be sure to set a corresponding model object on an ancestor view by calling its environmentObject(_:) modifier. Here's an example: class DataModel: ObservableObject { @Published var name = \"Some Name\" @Published var isEnabled = false } struct MyView: View { @StateObject private var model = DataModel() var body: some View { Text(model.name) MySubView() .environmentObject(model) } } struct MySubView: View { @EnvironmentObject var model: DataModel var body: some View { Toggle(\"Enabled\", isOn: $model.isEnabled) } } EnvironmentObject Documentation","title":"EnvironmentObject"},{"location":"swiftUI/#level-intermediate","text":"","title":"Level Intermediate"},{"location":"swiftUI/#module-13-components-in-swiftui","text":"","title":"Module 13: Components in SwiftUI"},{"location":"swiftUI/#button-part-i","text":"You create a button by providing an action and a label. The action is either a method or closure property that does something when a user clicks or taps the button. The label is a view that describes the button\u2019s action \u2014 for example, by showing text, an icon, or both. The label of a button can be any kind of view, such as a Text view for text-only labels or a Label view, for buttons with both a title and an icon: struct ButtonView: View { var body: some View { Button(action: signIn) { Text(\"Sign In\") // Only Title // Label(\"Sign In\", systemImage: \"arrow.up\") // Title and an icon } } func signIn { // do something } } Button Documentation","title":"Button Part I"},{"location":"swiftUI/#button-part-ii","text":"You can optionally initialize a button with a ButtonRole that characterizes the button\u2019s purpose. For example, you can create a destructive button for a deletion action: struct ButtonView: View { var body: some View { Button(\"Delete\", role: .destructive, action: delete) } func delete { // do something } } Button Documentation","title":"Button Part II"},{"location":"swiftUI/#button-part-iii","text":"You can customize a button\u2019s appearance using one of the standard button styles, like bordered , and apply the style with the buttonStyle(_:) modifier: struct ButtonView: View { var body: some View { Button(\"Sign In\", action: signIn) .buttonStyle(.bordered) } func signIn { // do something } } Button Documentation","title":"Button Part III"},{"location":"swiftUI/#textfield","text":"You create a text field with a label and a binding to a value. If the value is a string, the text field updates this value continuously as the user types or otherwise edits the text in the field. For non-string types, it updates the value when the user commits their edits, such as by pressing the Return key. The following example shows a text field to accept a username, and a Text view below it that shadows the continuously updated value of username. The Text view changes color as the user begins and ends editing. When the user submits their completed entry to the text field, the onSubmit(of:_:) modifer calls an internal validate(name:) method. struct TextFieldView: View { @State private var username: String = \"\" var body: some View { TextField( \"User name (email address)\", text: $username ) .onSubmit { // validate(name: username) } .textInputAutocapitalization(.never) .disableAutocorrection(true) .border(.secondary) Text(username) .foregroundColor(.blue) } } TextField Documentation","title":"TextField"},{"location":"swiftUI/#slider","text":"A control for selecting a value from a bounded linear range of values. A slider consists of a \u201cthumb\u201d image that the user moves between two extremes of a linear \u201ctrack\u201d. The ends of the track represent the minimum and maximum possible values. As the user moves the thumb, the slider updates its bound value. The following example shows a slider bound to the value speed. As the slider updates this value, a bound Text view shows the value updating. The onEditingChanged closure passed to the slider receives callbacks when the user drags the slider. The example uses this to change the color of the value text. struct SliderView: View { @State private var speed = 50.0 @State private var isEditing = false var body: some View { VStack { Slider( value: $speed, in: 0...100, onEditingChanged: { editing in isEditing = editing } ) Text(\"\\(speed)\") .foregroundColor(isEditing ? .red : .blue) } } } Slider Documentation","title":"Slider"},{"location":"swiftUI/#toggle","text":"A control for selecting a value from a bounded linear range of values. You create a toggle by providing an isOn binding and a label. Bind isOn to a Boolean property that determines whether the toggle is on or off. Set the label to a view that visually describes the purpose of switching between toggle states. For example: struct SliderView: View { @State private var vibrateOnRing = false var body: some View { Toggle(isOn: $vibrateOnRing) { Text(\"Vibrate on Ring\") } } } Toggle Documentation","title":"Toggle"},{"location":"swiftUI/#system-images","text":"Symbol images give you a consistent set of icons to use in your app, and ensure that those icons adapt to different sizes and to app-specific content. A symbol image contains a vector-based shape that scales without losing its sharpness. You generate its final appearance by applying a tint color, or if you\u2019re using SF Symbols 2 or later, you can apply multiple colors to add depth and emphasis to your symbol. You use symbol images in places where you display a simple shape or glyph, such as a bar button item. In SwiftUI, you use Image(systemName:) to load a system symbol image and Image(_:) to load your custom symbol, as the following code shows: struct SystemImagesView: View { var body: some View { // Create a system symbol image. Image(systemName: \"multiply.circle.fill\") } } System Images Documentation","title":"System Images"},{"location":"swiftUI/#module-14-navigation-and-views","text":"","title":"Module 14: Navigation and Views"},{"location":"swiftUI/#navigation","text":"A view that displays a root view and enables you to present additional views over the root view. Use a navigation stack to present a stack of views over a root view. People can add views to the top of the stack by clicking or tapping a NavigationLink , and remove views using built-in, platform-appropriate controls, like a Back button or a swipe gesture. The stack always displays the most recently added view that hasn\u2019t been removed, and doesn\u2019t allow the root view to be removed. To create navigation links, associate a view with a data type by adding a navigationDestination(for:destination:) modifier inside the stack\u2019s view hierarchy. Then initialize a NavigationLink that presents an instance of the same kind of data. This example defines a view with a list of names displayed using a NavigationStack . Each name in the list is a navigation link that, when tapped, navigates to a new view displaying the selected name as text. struct NavigationExampleView: View { var names: [String] = [\"Paul\", \"Abraham\", \"Leon\", \"Elias\", \"Eren\", \"Canel\"] var body: some View { NavigationStack { List(names) { name in NavigationLink(name, value: name) } .navigationDestination(for: String.self) { name in Text(name) } } } } NavigationStack Documentation","title":"Navigation"},{"location":"swiftUI/#tabview","text":"To create a user interface with tabs, place views in a TabView and apply the tabItem(_:) modifier to the contents of each tab. On iOS, you can also use one of the badge modifiers, like badge(_:) , to assign a badge to each of the tabs. This example defines a view with TabView containing two tabs. The first tab displays \"First Tab\" with a badge of \"2\" and an icon of a circle with the number 1. The second tab displays \"Second Tab\" with a badge of \"!\" and an icon of a circle with the number 2: struct TabViewExample: View { var body: some View { TabView { Text(\"First Tab\") .badge(\"2\") .tabItem { Image(systemName: \"1.circle\") Text(\"First\") } Text(\"Second Tab\") .badge(\"!\") .tabItem { Image(systemName: \"2.circle\") Text(\"Second\") } } } } TabView Documentation","title":"TabView"},{"location":"swiftUI/#level-advanced","text":"","title":"Level Advanced"},{"location":"swiftUI/#module-15-advanced-swiftui-lectures","text":"","title":"Module 15: Advanced SwiftUI-Lectures"},{"location":"swiftUI/#rotation-effect","text":"Rotates a view\u2019s rendered output in two dimensions around the specified point. This example defines a view that includes a state variable isRotated initialized to false to control the rotation of an arrow image. The view contains an Image that rotates 90 degrees when isRotated is true , with an ease-in-out animation of 1 second. Tapping the image toggles the rotation state: struct BasicAnimationView: View { @State private var isRotated = false var body: some View { Image(systemName: \"arrow.right.circle.fill\") .rotationEffect(.degrees(isRotated ? 90 : 0)) .animation(.easeInOut(duration: 1)) .onTapGesture { isRotated.toggle() } } } RotationEffect Documentation","title":"Rotation Effect"},{"location":"swiftUI/#scale-effects","text":"Scales this view\u2019s rendered output by the given vertical and horizontal size amounts, relative to an anchor point. This example defines a view that includes a state variable scale initialized to 1.0 to control the scaling of a star image. The view contains a vertically stacked Image with a scaling effect and animation, and a button that increases the scale by 0.5 when tapped, triggering the animation. struct AnimationView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { Image(systemName: \"star.fill\") .scaleEffect(scale) .animation(.easeInOut(duration: 1)) Button(\"Animate\") { scale += 0.5 } } } } ScaleEffect Documentation","title":"Scale Effects"},{"location":"swiftUIQuiz/","text":"Quizzes for SwiftUI Table of contents Beginner Module 11: Introduction to SwiftUI Quiz 1: Create a Greeting View Quiz 2: Create a Simple VStack Quiz 3: Create a Complex HStack Quiz 4: Overlay Views in ZStack Module 12: State Management in SwiftUI Quiz 1: Switch between On and Off Quiz 2: Bind a Toggle Button Module 13: Components in SwiftUI Quiz 1: Create a Submit Button Quiz 2: Create an Update Button Quiz 3: Create an Email TextField Quiz 4: Create a Volume Slider Intermediate Module 14: Navigation and Views Quiz 1: Create a Food Navigation Stack Quiz 2: Create a Category Tab View Advanced Module 15: Advanced SwiftUI-Lectures Quiz 1: Create a Rotating Arrow Quiz 2: Create a Pulsing Heart Level Beginner Module 11: Introduction to SwiftUI Quiz 1: Create a Greeting View Description : Create a GreetingView struct in SwiftUI that displays the text \"Welcome to SwiftUI!\" with a font size of 30 and color green. Starting Code : struct GreetingView: View { var body: some View { ... } } Solution Code : struct GreetingView: View { var body: some View { Text(\"Welcome to SwiftUI!\") .font(.system(size: 30)) .foregroundColor(.green) } } Quiz 2: Create a Simple VStack Description : Create a SimpleVStackView struct in SwiftUI that displays a vertical stack of 3 text views, each showing the text \"Item X\" where X is the item number, with a spacing of 15 and center alignment. Starting Code : struct SimpleVStackView: View { var body: some View { VStack { ... } } } Solution Code : struct SimpleVStackView: View { var body: some View { VStack( alignment: .center, spacing: 15 ) { ForEach(1...3, id: \\.self) { item in Text(\"Item \\(item)\") } } } } Quiz 3: Create a Complex HStack Description : Create a ComplexHStackView struct in SwiftUI that displays a horizontal stack of 4 text views, each showing the text \"Element X\" where X is the element number, with a spacing of 20 and bottom alignment. Starting Code : struct ComplexHStackView: View { var body: some View { HStack { ... } } } Solution Code : struct ComplexHStackView: View { var body: some View { HStack( alignment: .bottom, spacing: 20 ) { ForEach(1...4, id: \\.self) { element in Text(\"Element \\(element)\") } } } } Quiz 4: Overlay Views in ZStack Description : Create a OverlayZStackView struct in SwiftUI that displays a green rectangle with a width and height of 200 points, and overlays a pink text \"Center View\" on top of it. Starting Code : struct OverlayZStackView: View { var body: some View { ZStack { ... } } } Solution Code : struct OverlayZStackView: View { var body: some View { ZStack { Rectangle() .fill(Color.green) .frame(width: 200, height: 200) Text(\"Center View\") .foregroundColor(.pink) } } } Module 12: State Management in SwiftUI Quiz 1: Switch between On and Off Description : Create a ToggleSwitch struct in SwiftUI that switches between \"On\" and \"Off\" when clicked, using a state variable. Starting Code : struct ToggleSwitch: View { @State private var isOn: Bool = false var body: some View { ... } } Solution Code : struct ToggleSwitch: View { @State private var isOn: Bool = false var body: some View { Button(isOn ? \"Off\" : \"On\") { isOn.toggle() } } } Quiz 2: Bind a Toggle Button Description : 1) Create a ToggleButton struct in SwiftUI that toggles between \"Start\" and \"Stop\" using a binding variable. 2) Then, create a ControlView struct that uses ToggleButton and binds its isStarted state. Starting Code : struct ToggleButton: View { @Binding private var isStarted: Bool var body: some View { ... } } struct ControlView: View { @State private var isStarted: Bool = false var body: some View { ... } } Solution Code : struct ToggleButton: View { @Binding private var isStarted: Bool var body: some View { Button(isStarted ? \"Stop\" : \"Start\") { isStarted.toggle() } } } struct ControlView: View { @State private var isStarted: Bool = false var body: some View { VStack { ToggleButton(isStarted: $isStarted) } } } Module 13: Components in SwiftUI Quiz 1: Create a Submit Button Description : 1) Create a SubmitButtonView struct in SwiftUI that displays a button with the title \"Submit\". 2) The button should call a function submit when tapped. Starting Code : struct SubmitButtonView: View { var body: some View { Button(action: submit) { ... } } func submit() { // perform submit action } } Solution Code : struct SubmitButtonView: View { var body: some View { Button(action: submit) { Text(\"Submit\") } } func submit() { // perform submit action } } Quiz 2: Create an Update Button Description : 1) Create a UpdateButtonView struct in SwiftUI that displays a button with the title \"Update\" and a prominent role. 2) The button should call a function update when tapped. Starting Code : struct UpdateButtonView: View { var body: some View { Button(\"Update\", role: .prominent, action: update) } func update() { // perform update action } } Solution Code : struct UpdateButtonView: View { var body: some View { Button(\"Update\", role: .prominent, action: update) } func update() { // perform update action } } Quiz 3: Create an Email TextField Description : 1) Create a EmailTextFieldView struct in SwiftUI that displays a text field with the placeholder \"Email address\" for entering an email. 2) The text field should have a border of a secondary color, disable autocorrection, and use no text input autocapitalization. 3) Below the text field, display the entered email in red text. Starting Code : struct EmailTextFieldView: View { @State private var email: String = \"\" var body: some View { VStack { ... } } } Solution Code : struct EmailTextFieldView: View { @State private var email: String = \"\" var body: some View { VStack { TextField(\"Email address\", text: $email) .textInputAutocapitalization(.never) .disableAutocorrection(true) .border(.secondary) Text(email) .foregroundColor(.red) } } } Quiz 4: Create a Volume Slider Description : 1) Create a VolumeSliderView struct in SwiftUI that displays a slider for selecting a volume value between 0 and 100. 2) Below the slider, display the selected volume value in green text while editing and gray text otherwise. Starting Code : struct VolumeSliderView: View { @State private var volume = 50.0 @State private var isEditing = false var body: some View { VStack { ... } } } Solution Code : struct VolumeSliderView: View { @State private var volume = 50.0 @State private var isEditing = false var body: some View { VStack { Slider( value: $volume, in: 0...100, onEditingChanged: { editing in isEditing = editing } ) Text(\"\\(volume)\") .foregroundColor(isEditing ? .green : .gray) } } } Level Intermediate Module 14: Navigation and Views Quiz 1: Create a Food Navigation Stack Description : 1) Create a FoodNavigationView struct in SwiftUI that displays a list of food items using a NavigationStack . 2) Each food item should be a navigation link that navigates to a new view displaying the selected food name. Starting Code : struct FoodNavigationView: View { var foodItems: [String] = [\"Apple\", \"Banana\", \"Carrot\", \"Date\", \"Eggplant\"] var body: some View { NavigationStack { ... } } } Solution Code : struct FoodNavigationView: View { var foodItems: [String] = [\"Apple\", \"Banana\", \"Carrot\", \"Date\", \"Eggplant\"] var body: some View { NavigationStack { List(foodItems, id: \\.self) { food in NavigationLink(food, value: food) } .navigationDestination(for: String.self) { food in Text(food) } } } } Quiz 2: Create a Category Tab View Description : 1) Create a CategoryTabView struct in SwiftUI that displays a TabView with two tabs. 2) The first tab should display \"Fruits\" with a badge of \"5\" and an icon of an apple. 3) The second tab should display \"Vegetables\" with a badge of \"3\" and an icon of a carrot. Starting Code : struct CategoryTabView: View { var body: some View { TabView { ... } } } Solution Code : struct CategoryTabView: View { var body: some View { TabView { Text(\"Fruits\") .badge(\"5\") .tabItem { Image(systemName: \"applelogo\") Text(\"Fruits\") } Text(\"Vegetables\") .badge(\"3\") .tabItem { Image(systemName: \"leaf\") Text(\"Vegetables\") } } } } Level Advanced Module 15: Advanced SwiftUI-Lectures Quiz 1: Create a Rotating Arrow Description : Create a RotatingArrowView struct in SwiftUI that displays an arrow image which rotates 180 degrees when tapped, with an ease-out animation of 2 seconds. Starting Code : struct RotatingArrowView: View { @State private var isRotated = false var body: some View { ... } } Solution Code : struct RotatingArrowView: View { @State private var isRotated = false var body: some View { Image(systemName: \"arrow.right.circle.fill\") .rotationEffect(.degrees(isRotated ? 180 : 0)) .animation(.easeOut(duration: 2), value: isRotated) .onTapGesture { isRotated.toggle() } } } Quiz 2: Create a Pulsing Heart Description : Create a PulsingHeartView struct in SwiftUI that displays a heart image which scales up by 0.2 when a button is tapped, with an ease-in animation of 0.5 seconds. Starting Code : struct PulsingHeartView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { ... } } } Solution Code : ```swift struct PulsingHeartView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { Image(systemName: \"heart.fill\") .scaleEffect(scale) .animation(.easeIn(duration: 0.5), value: scale) Button(\"Pulse\") { scale += 0.2 } } } }","title":"SwiftUI-Quizzes"},{"location":"swiftUIQuiz/#quizzes-for-swiftui","text":"","title":"Quizzes for SwiftUI"},{"location":"swiftUIQuiz/#table-of-contents","text":"Beginner Module 11: Introduction to SwiftUI Quiz 1: Create a Greeting View Quiz 2: Create a Simple VStack Quiz 3: Create a Complex HStack Quiz 4: Overlay Views in ZStack Module 12: State Management in SwiftUI Quiz 1: Switch between On and Off Quiz 2: Bind a Toggle Button Module 13: Components in SwiftUI Quiz 1: Create a Submit Button Quiz 2: Create an Update Button Quiz 3: Create an Email TextField Quiz 4: Create a Volume Slider Intermediate Module 14: Navigation and Views Quiz 1: Create a Food Navigation Stack Quiz 2: Create a Category Tab View Advanced Module 15: Advanced SwiftUI-Lectures Quiz 1: Create a Rotating Arrow Quiz 2: Create a Pulsing Heart","title":"Table of contents"},{"location":"swiftUIQuiz/#level-beginner","text":"","title":"Level Beginner"},{"location":"swiftUIQuiz/#module-11-introduction-to-swiftui","text":"","title":"Module 11: Introduction to SwiftUI"},{"location":"swiftUIQuiz/#quiz-1-create-a-greeting-view","text":"Description : Create a GreetingView struct in SwiftUI that displays the text \"Welcome to SwiftUI!\" with a font size of 30 and color green. Starting Code : struct GreetingView: View { var body: some View { ... } } Solution Code : struct GreetingView: View { var body: some View { Text(\"Welcome to SwiftUI!\") .font(.system(size: 30)) .foregroundColor(.green) } }","title":"Quiz 1: Create a Greeting View"},{"location":"swiftUIQuiz/#quiz-2-create-a-simple-vstack","text":"Description : Create a SimpleVStackView struct in SwiftUI that displays a vertical stack of 3 text views, each showing the text \"Item X\" where X is the item number, with a spacing of 15 and center alignment. Starting Code : struct SimpleVStackView: View { var body: some View { VStack { ... } } } Solution Code : struct SimpleVStackView: View { var body: some View { VStack( alignment: .center, spacing: 15 ) { ForEach(1...3, id: \\.self) { item in Text(\"Item \\(item)\") } } } }","title":"Quiz 2: Create a Simple VStack"},{"location":"swiftUIQuiz/#quiz-3-create-a-complex-hstack","text":"Description : Create a ComplexHStackView struct in SwiftUI that displays a horizontal stack of 4 text views, each showing the text \"Element X\" where X is the element number, with a spacing of 20 and bottom alignment. Starting Code : struct ComplexHStackView: View { var body: some View { HStack { ... } } } Solution Code : struct ComplexHStackView: View { var body: some View { HStack( alignment: .bottom, spacing: 20 ) { ForEach(1...4, id: \\.self) { element in Text(\"Element \\(element)\") } } } }","title":"Quiz 3: Create a Complex HStack"},{"location":"swiftUIQuiz/#quiz-4-overlay-views-in-zstack","text":"Description : Create a OverlayZStackView struct in SwiftUI that displays a green rectangle with a width and height of 200 points, and overlays a pink text \"Center View\" on top of it. Starting Code : struct OverlayZStackView: View { var body: some View { ZStack { ... } } } Solution Code : struct OverlayZStackView: View { var body: some View { ZStack { Rectangle() .fill(Color.green) .frame(width: 200, height: 200) Text(\"Center View\") .foregroundColor(.pink) } } }","title":"Quiz 4: Overlay Views in ZStack"},{"location":"swiftUIQuiz/#module-12-state-management-in-swiftui","text":"","title":"Module 12: State Management in SwiftUI"},{"location":"swiftUIQuiz/#quiz-1-switch-between-on-and-off","text":"Description : Create a ToggleSwitch struct in SwiftUI that switches between \"On\" and \"Off\" when clicked, using a state variable. Starting Code : struct ToggleSwitch: View { @State private var isOn: Bool = false var body: some View { ... } } Solution Code : struct ToggleSwitch: View { @State private var isOn: Bool = false var body: some View { Button(isOn ? \"Off\" : \"On\") { isOn.toggle() } } }","title":"Quiz 1: Switch between On and Off"},{"location":"swiftUIQuiz/#quiz-2-bind-a-toggle-button","text":"Description : 1) Create a ToggleButton struct in SwiftUI that toggles between \"Start\" and \"Stop\" using a binding variable. 2) Then, create a ControlView struct that uses ToggleButton and binds its isStarted state. Starting Code : struct ToggleButton: View { @Binding private var isStarted: Bool var body: some View { ... } } struct ControlView: View { @State private var isStarted: Bool = false var body: some View { ... } } Solution Code : struct ToggleButton: View { @Binding private var isStarted: Bool var body: some View { Button(isStarted ? \"Stop\" : \"Start\") { isStarted.toggle() } } } struct ControlView: View { @State private var isStarted: Bool = false var body: some View { VStack { ToggleButton(isStarted: $isStarted) } } }","title":"Quiz 2: Bind a Toggle Button"},{"location":"swiftUIQuiz/#module-13-components-in-swiftui","text":"","title":"Module 13: Components in SwiftUI"},{"location":"swiftUIQuiz/#quiz-1-create-a-submit-button","text":"Description : 1) Create a SubmitButtonView struct in SwiftUI that displays a button with the title \"Submit\". 2) The button should call a function submit when tapped. Starting Code : struct SubmitButtonView: View { var body: some View { Button(action: submit) { ... } } func submit() { // perform submit action } } Solution Code : struct SubmitButtonView: View { var body: some View { Button(action: submit) { Text(\"Submit\") } } func submit() { // perform submit action } }","title":"Quiz 1: Create a Submit Button"},{"location":"swiftUIQuiz/#quiz-2-create-an-update-button","text":"Description : 1) Create a UpdateButtonView struct in SwiftUI that displays a button with the title \"Update\" and a prominent role. 2) The button should call a function update when tapped. Starting Code : struct UpdateButtonView: View { var body: some View { Button(\"Update\", role: .prominent, action: update) } func update() { // perform update action } } Solution Code : struct UpdateButtonView: View { var body: some View { Button(\"Update\", role: .prominent, action: update) } func update() { // perform update action } }","title":"Quiz 2: Create an Update Button"},{"location":"swiftUIQuiz/#quiz-3-create-an-email-textfield","text":"Description : 1) Create a EmailTextFieldView struct in SwiftUI that displays a text field with the placeholder \"Email address\" for entering an email. 2) The text field should have a border of a secondary color, disable autocorrection, and use no text input autocapitalization. 3) Below the text field, display the entered email in red text. Starting Code : struct EmailTextFieldView: View { @State private var email: String = \"\" var body: some View { VStack { ... } } } Solution Code : struct EmailTextFieldView: View { @State private var email: String = \"\" var body: some View { VStack { TextField(\"Email address\", text: $email) .textInputAutocapitalization(.never) .disableAutocorrection(true) .border(.secondary) Text(email) .foregroundColor(.red) } } }","title":"Quiz 3: Create an Email TextField"},{"location":"swiftUIQuiz/#quiz-4-create-a-volume-slider","text":"Description : 1) Create a VolumeSliderView struct in SwiftUI that displays a slider for selecting a volume value between 0 and 100. 2) Below the slider, display the selected volume value in green text while editing and gray text otherwise. Starting Code : struct VolumeSliderView: View { @State private var volume = 50.0 @State private var isEditing = false var body: some View { VStack { ... } } } Solution Code : struct VolumeSliderView: View { @State private var volume = 50.0 @State private var isEditing = false var body: some View { VStack { Slider( value: $volume, in: 0...100, onEditingChanged: { editing in isEditing = editing } ) Text(\"\\(volume)\") .foregroundColor(isEditing ? .green : .gray) } } }","title":"Quiz 4: Create a Volume Slider"},{"location":"swiftUIQuiz/#level-intermediate","text":"","title":"Level Intermediate"},{"location":"swiftUIQuiz/#module-14-navigation-and-views","text":"","title":"Module 14: Navigation and Views"},{"location":"swiftUIQuiz/#quiz-1-create-a-food-navigation-stack","text":"Description : 1) Create a FoodNavigationView struct in SwiftUI that displays a list of food items using a NavigationStack . 2) Each food item should be a navigation link that navigates to a new view displaying the selected food name. Starting Code : struct FoodNavigationView: View { var foodItems: [String] = [\"Apple\", \"Banana\", \"Carrot\", \"Date\", \"Eggplant\"] var body: some View { NavigationStack { ... } } } Solution Code : struct FoodNavigationView: View { var foodItems: [String] = [\"Apple\", \"Banana\", \"Carrot\", \"Date\", \"Eggplant\"] var body: some View { NavigationStack { List(foodItems, id: \\.self) { food in NavigationLink(food, value: food) } .navigationDestination(for: String.self) { food in Text(food) } } } }","title":"Quiz 1: Create a Food Navigation Stack"},{"location":"swiftUIQuiz/#quiz-2-create-a-category-tab-view","text":"Description : 1) Create a CategoryTabView struct in SwiftUI that displays a TabView with two tabs. 2) The first tab should display \"Fruits\" with a badge of \"5\" and an icon of an apple. 3) The second tab should display \"Vegetables\" with a badge of \"3\" and an icon of a carrot. Starting Code : struct CategoryTabView: View { var body: some View { TabView { ... } } } Solution Code : struct CategoryTabView: View { var body: some View { TabView { Text(\"Fruits\") .badge(\"5\") .tabItem { Image(systemName: \"applelogo\") Text(\"Fruits\") } Text(\"Vegetables\") .badge(\"3\") .tabItem { Image(systemName: \"leaf\") Text(\"Vegetables\") } } } }","title":"Quiz 2: Create a Category Tab View"},{"location":"swiftUIQuiz/#level-advanced","text":"","title":"Level Advanced"},{"location":"swiftUIQuiz/#module-15-advanced-swiftui-lectures","text":"","title":"Module 15: Advanced SwiftUI-Lectures"},{"location":"swiftUIQuiz/#quiz-1-create-a-rotating-arrow","text":"Description : Create a RotatingArrowView struct in SwiftUI that displays an arrow image which rotates 180 degrees when tapped, with an ease-out animation of 2 seconds. Starting Code : struct RotatingArrowView: View { @State private var isRotated = false var body: some View { ... } } Solution Code : struct RotatingArrowView: View { @State private var isRotated = false var body: some View { Image(systemName: \"arrow.right.circle.fill\") .rotationEffect(.degrees(isRotated ? 180 : 0)) .animation(.easeOut(duration: 2), value: isRotated) .onTapGesture { isRotated.toggle() } } }","title":"Quiz 1: Create a Rotating Arrow"},{"location":"swiftUIQuiz/#quiz-2-create-a-pulsing-heart","text":"Description : Create a PulsingHeartView struct in SwiftUI that displays a heart image which scales up by 0.2 when a button is tapped, with an ease-in animation of 0.5 seconds. Starting Code : struct PulsingHeartView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { ... } } } Solution Code : ```swift struct PulsingHeartView: View { @State private var scale: CGFloat = 1.0 var body: some View { VStack { Image(systemName: \"heart.fill\") .scaleEffect(scale) .animation(.easeIn(duration: 0.5), value: scale) Button(\"Pulse\") { scale += 0.2 } } } }","title":"Quiz 2: Create a Pulsing Heart"}]}